<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> Model interface </title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
            #visual-modeling-heading {
                margin: 0; /* Remove default margin */
                padding: 5px 50px; /* Minimal padding for better spacing */
                font-size: 1.5rem; /* Adjust font size if needed */
                text-align: left; /* Center the heading */
            }

            body {
                display: flex;
                flex-direction: column; /* Change layout direction to column */
                font-family: Arial, sans-serif;
                min-height: 100vh; /* Full viewport height */
                margin: 0; /* Remove default margin */
            }

            .blank-space {
                display: flex; /* Use flexbox for layout */
                flex-direction: row; /* Arrange children in a row */
                gap: 10px; /* Add spacing between columns */
                width: 100%; /* Full width of the container */
                height: auto; /* Adjust height automatically */
                padding: 10px; /* Add padding inside the container */
                box-sizing: border-box; /* Include padding in the width and height */
            }

            .blank-space-column {
                display: flex; /* Optional: For inner alignment */
                flex-direction: column; /* Stack content vertically */
                padding: 10px; /* Add padding inside each column */
                
                box-sizing: border-box; /* Ensure padding doesn't affect size */
            }

            .column-1 {
                flex: 1; /* n parts of the available space */
                background-color: None; 
            }

            .column-2 {
                flex: 4; /* n parts of the available space */
                background-color: #f9f9f9; /* Optional: Light background for each column */
                border: 1px solid #ddd; /* Optional: Subtle border */
            }

            .column-3 {
                flex: 1; /* n part of the available space */
                background-color: #f9f9f9; /* Optional: Light background for each column */
                border: 1px solid #ddd; /* Optional: Subtle border */
            }

            .visualization-area {
                height: 60%; /* Adjust height for the bottom section */
                padding: 10px;
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                box-sizing: border-box;
                overflow-y: auto; /* Enable vertical scrolling */
                overflow-x: hidden; /* Hide horizontal scrolling */
            }

            .text-feature-container {
                display: flex;
                align-items: flex-start;
                justify-content: space-between;
                gap: 20px; /* Adjust spacing between text boxes and feature list */
                width: 100%; /* Ensure it takes up the full width */
                margin-bottom: 10px; /* Space below this container */
            }

            .text-boxes {
                flex: 1; /* Allocate more space to the text boxes */
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .feature-list {
                flex: 1; /* Allocate less space to the feature list */
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                justify-content: flex-start; /* Align items to the start */
                align-content: flex-start; /* Allow wrapping to new lines */
                max-height: 200px; /* Optional: Limit height and enable scrolling if necessary */
                overflow-y: auto;
                border: 1px solid #ddd; /* Optional: Add border to separate visually */
                padding: 10px; /* Optional: Add padding */
                background-color: #f9f9f9; /* Optional: Background for better visibility */
            }

            .feature-item {
                padding: 5px 8px; /* Reduce padding for smaller size */
                font-size: 12px; /* Reduce font size for compact appearance */
                margin: 2px; /* Add small margins for spacing */
                background-color: #f0f0f0;
                border: 1px solid #ccc;
                cursor: grab;
                white-space: nowrap;
                border-radius: 4px; /* Optional: add rounded corners */
            }

            .prediction-item {
                background-color: #d3e4ff; /* Light blue background for predictions */
                border: 1px solid #6bafff; /* Slightly darker border */
            }

            .residual-item {
                background-color: #ffcccc; /* Light red background for predictions */
                border: 1px solid #ff0000; /* Slightly darker border */
            }

            .drop-area {
                width: 100%;
                padding: 10px;
                border: 1px dashed #ccc;
                min-height: 210px;
                position: relative;
            }
            .plot {
                border: 1px solid #ccc;
                padding: 10px;
                margin-top: 10px;
            }

            .tooltip {
                box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            }

            form#modelForm {
                display: flex;
                gap: 10px;
                align-items: center;
                margin-bottom: 10px;
            }
            form#modelForm input {
                flex-grow: 1;
                padding: 5px;
                font-size: 12px;
            }
           
            .clickable-model {
                cursor: pointer; /* Show pointer cursor on hover */
                color: blue; /* Make the text blue to signify it's clickable */
                text-decoration: underline; /* Optional: underline for clickable elements */
            }

            .flip-button {
                background-color: #f0f0f0;
                border: 1px solid #ccc;
                padding: 3px 5px;
                font-size: 10px;
                cursor: pointer;
                border-radius: 4px;
            }

            .flip-button:hover {
                background-color: #e0e0e0;
            }

            .stat-values {
                color: darkgreen;
            }

            #controls-section {
                display: flex;         /* Align items horizontally */
                gap: 10px;             /* Add space between buttons */
                flex-wrap: wrap;       /* Allow buttons to wrap to the next line if needed */
                margin-bottom: 10px;   /* Add space below the button group */
            }

            #controls-section button {
                padding: 5px 10px;     /* Adjust padding for buttons */
                font-size: 12px;       /* Standardize font size */
                border-radius: 10px;    /* Add rounded corners */
                background-color: #90ee90; /* Light green */
                border: 1px solid #ccc; /* Optional: Add a border for consistency */
                cursor: pointer;       /* Change cursor to pointer on hover */
            }

            #controls-section button:hover {
                background-color: #76c776; /* Darker green on hover */
            }

            #systemText {
                font-size: 13px; /* Make the text smaller */
                width: 100%; /* Match the textbox width */
                word-wrap: break-word; /* Force text to break within the width */
                margin: 0 auto 5px; /* Center align and add spacing below */
                box-sizing: border-box; /* Include padding in the width */
            }

            #userInput {
                resize: vertical; /* Allow vertical resizing only */
                width: 100%; /* Fixed width */
                height: 25px; /* Default height */
                font-size: 12px; /* Smaller font size for readability */
                padding: 5px; /* Add padding for better text appearance */
                box-sizing: border-box; /* Ensure padding doesn't affect width */
            }

            .hypothesis-table {
                font-size: 13px; /* Adjust the font size */
                color: #333; /* Text color */
                border: 1px solid #ccc; /* Border for the table */
            }

            .hypothesis-table th, .hypothesis-table td {
                border: 1px solid #ccc; /* Cell borders */
                padding: 8px; /* Padding inside cells */
                text-align: left; /* Align text to the left */
            }

            .hypothesis-table th {
                background-color: #f4f4f4; /* Background color for headers */
            }

            .hypothesis-table th:nth-child(1):hover,
            .hypothesis-table th:nth-child(2):hover,
            .hypothesis-table th:nth-child(3):hover {
                background-color: #d0e0ff !important; /* Light blue for hover effect */
            }

            .hypothesis_row {
              display: flex;
              align-items: center;
              gap: 10px;
            }

            .hypothesis_row textarea {
                flex: 1;
                height: 50px; 
                padding: 5px;
                font-size: 12px;
            }
                        
            .hypothesis_row button {
                padding: 5px 10px;
                font-size: 12px;
                background-color: #FABF7C;
                border-radius: 10px;
                border: 1px solid #ccc;
                cursor: pointer;
            }
            
            .hypothesis_row button:hover {
                background-color: #e1ae74;
            }

            /* Container for each model entry */
            .model-entry {
                background: #f0f0f0; 
                padding: 0px; 
                box-shadow: inset 0px -2px 4px rgba(0, 0, 0, 0.2); 
                border: 1px solid #ddd; 
                display: flex;
                flex-direction: column;
            }
            
            /* Model header row */
            .model-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 4px 4px;
            }
            
            .expand-icon {
                transition: transform 0.3s ease;
                height: 12px;
            }
            
            .rotate-arrow {
                transform: rotate(90deg); /* Rotates the arrow from right to down */
            }

            /* Model title */
            .model-header span {
                flex-grow: 1; /* Let it expand */
                text-align: left; /* Align text to the left */
                font-size: 12px;
                font-weight: bold;
                margin-left: 10px; /* Space between expand button and text */
                align-items: center;
            }
            
            /* Style for expanded formula details */
            .formula-details {
                padding: 5px 20px;
                background: #d9d9d9;
                font-size: 12px;
                box-shadow: inset 0px 2px 4px rgba(0, 0, 0, 0.2);
                border-top: 1px solid #ddd;
            }

            .categorical-feature {
                position: relative;
            }

            .category-dropdown {
                position: absolute;
                left: 0;
                top: 100%;
                display: none;
                background: #f9f9f9;
                border: 1px solid #ddd;
                z-index: 10;
                min-width: 50px;
            }

            .category-item:hover {
                background: #ddd;
            }

            label[for="formulaMean"],
            label[for="formulaStdDev"],
            label[for="distributionSelect"] {
                font-size: 14px; /* Reduce label size */
            }

            #generate-models {
                display: none;
            }
           
          </style>
</head>
<body>
        <div style="display: flex; align-items: center; gap: 10px;">
            <h3 id="visual-modeling-heading">Visual Modeling Tool</h3>
            <label for="datasetSelect" style="white-space: nowrap;">Dataset:</label>
            <select id="datasetSelect">
                <option value="" disabled selected>Select dataset</option>
                <option value="life_expectancy">Life Expectancy</option>
                <option value="airline">Flight Price</option>
            </select>
            <button id="apply-category-filter" style="padding: 3px 5px; font-size: 11px; border-radius: 5px; border: 1px solid #ccc; cursor: pointer;">
                Apply Filter
            </button>
            <span id="filter-message" style="margin-left: 10px; font-size: 12px; color: black;"></span>

        </div>

        <div class="visualization-area">
            
            <div class="text-feature-container">
                <!-- Text Boxes Section -->
                <div class="text-boxes">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="formulaMean" style="white-space: nowrap;">Mean:</label>
                        <input type="text" id="formulaMean" name="formulaMean" 
                            placeholder="e.g., y ~ x1 + x2 + x3*x4" 
                            required 
                            style="flex-grow: 1; width: 300px;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="formulaStdDev" style="white-space: nowrap;">Standard Deviation:</label>
                        <input type="text" id="formulaStdDev" name="formulaStdDev" 
                            value="~ 1"
                            placeholder="e.g., y ~ x1 + x2" 
                            required 
                            style="flex-grow: 1; width: 300px;">
                    </div>

                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="distributionSelect" style="white-space: nowrap;">Distribution:</label>
                        <select id="distributionSelect">
                            <option value="NO()">Normal</option>
                            <option value="GA()">Gamma</option>
                            <option value="LOGNO()">Log-Normal</option>
                        </select>
                    </div>

                    <div id="controls-section">
                        <button id="fit-model-button" style="align-self: flex-start;">Fit Model</button>
                        <button id="generate-correlation-matrix">Correlation Matrix</button>
                        <button id="cycle-predictions">Activate HOPs</button>
                        <button id="normalize-axes">Normalize Axes</button>                        
                    </div>
                </div>
        
                <!-- Feature List Section -->
                <div class="feature-list" id="feature-list"></div>
            </div>
        
            <div class="drop-area" id="drop-area"></div>
            <button id="clear-charts">Clear All Charts</button>
        </div>
    
        <div class="blank-space">
            <!-- Third Column -->
            <div class="blank-space-column column-3">

                <button id="generate-models">Generate candidate models</button> 

                <div style="display: flex; align-items: center; gap: 10px;">
                    <label class="switch">
                        <input type="checkbox" id="autoGenerateToggle">
                        <span class="slider round"></span>
                    </label>
                    <span style="font-size: 14px;"> Generate Models</span>
                </div>
                

                
                <div id="generated-models-output" style="font-family: monospace; white-space: pre-line;"></div>
            </div>

            <!-- First Column -->
            <div class="blank-space-column column-1">
                <div id="Model-List" style="margin-bottom: 10px;"></div>
            </div>
        
            <!-- Second Column -->
            <div class="blank-space-column column-2">
                

                <div id="chatgptButtons"></div>
                <p id="systemText">Describe your hypothesis</p>
                <div class="hypothesis_row">
                    <textarea id="userInput" placeholder=""></textarea>
                    <button class="chat-button" onclick="matchHypotheses()">Generate Hypotheses</button>
                    <!--<button class="chat-button" onclick="callOpenAI()">Generate Formula</button>-->
                </div>
                <div id="hypothesis-counter" style="text-align: right; font-size: 12px; font-weight: regular; margin-top: 10px;">
                    Total Hypotheses: <span id="total-hypotheses">0</span>
                </div>
                <div id="hypothesis-logs"></div>
                <p id="response"></p>

            </div>
        
            
        </div>
            

   
  <script>
    const bar_col = "#ccc";
    const baseChart_col = "#69b3a2"; // scatterplot
    //const baseChart_col = "#c7c7c7";
    const predictChart_col = "#0096FF";
    const brush_col = "orange";
    const residual_col = "#ff0000";

    let features
    let current_dataset
    let full_dataset

    let autoGenerateModels = false; // Default: off


    // Dataset selection handling
    document.getElementById("datasetSelect").addEventListener("change", function () {
        const selectedDataset = this.value;
        current_dataset = selectedDataset;
        switchDataset(selectedDataset);
    });

    // Function to switch datasets
    function switchDataset(datasetName) {

        // remove previous content and reset some values
        document.getElementById('total-hypotheses').textContent = 0;
        predCounter = 1;

        d3.select("#drop-area").selectAll("*").remove();
        d3.select("#feature-list").selectAll("*").remove();
        d3.select("#Model-List").selectAll("*").remove();
        d3.select("#hypothesis-logs").selectAll("*").remove();

        document.getElementById("formulaMean").value = ""; 
        document.getElementById("formulaStdDev").value = "~ 1"; 
        document.getElementById("distributionSelect").value = "NO()"; 
        document.getElementById("userInput").value = ""; 

        document.getElementById("filter-message").textContent = "Full dataset";
        
        let datasetPath, newFeatures;
        
        if (datasetName === "life_expectancy") {
            datasetPath = "data/LifeExpect.csv";
            newFeatures = [
                    { name: "Life expectancy", key: "Life_expectancy", type: "continuous" },
                    //{ name: "Infant mortality",  key: "Infant_deaths", type: "continuous" },
                    //{ name: "Under-5 mortality", key: "Under_five_deaths", type: "continuous" },
                    //{ name: "Adult mortality", key: "Adult_mortality", type: "continuous" },
                    { name: "Alcohol consumption", key: "Alcohol_consumption", type: "continuous" },
                    { name: "Hepatitis B", key: "Hepatitis_B", type: "continuous" },
                    { name: "Measles", key: "Measles", type: "continuous" },
                    { name: "BMI", key: "BMI", type: "continuous" },
                    { name: "Polio", key: "Polio", type: "continuous" },
                    { name: "Diphtheria", key: "Diphtheria", type: "continuous" },
                    { name: "Incidents HIV", key: "Incidents_HIV", type: "continuous" },
                    { name: "GDP per capita (USD)", key: "GDP_per_capita", type: "continuous" },
                    { name: "Population (millions)", key: "Population_mln", type: "continuous" },
                    { name: "Thinness (10-19 Years)", key: "Thinness_ten_nineteen_years", type: "continuous" },
                    { name: "Thinness (5-9 Years)", key: "Thinness_five_nine_years", type: "continuous" },
                    { name: "Schooling", key: "Schooling", type: "continuous" },
                    { name: "Developed country", key: "Developed_country", type: "categorical" }
            ];
        } else if (datasetName === "airline") {
            datasetPath = "data/cleaned_airline.csv";
            newFeatures = [
                { name: "Price", key: "price", type: "continuous" },
                { name: "Days remaining", key: "days_remain", type: "continuous" },
                { name: "Flight duration", key: "duration", type: "continuous" },
                { name: "Class", key: "class", type: "categorical" },
                { name: "Destination", key: "destination", type: "categorical" },
                { name: "Arrival", key: "arrival", type: "categorical" },
                { name: "Stops", key: "stops", type: "categorical" },
                { name: "Departure", key: "departure", type: "categorical" },
                { name: "Origin", key: "origin", type: "categorical" },
                { name: "Airline", key: "airline", type: "categorical" }
            ];
        }

        features = newFeatures

        // Load the new dataset
        datasetPath = "data/cleaned_airline.csv";
        d3.csv(datasetPath).then(data => {
            dataset = data;
            full_dataset = data;
            dataset.forEach(d => {
                Object.keys(d).forEach(key => {
                    d[key] = isNaN(+d[key]) ? d[key] : +d[key]; // Convert numeric values
                });
            });

            // Update feature list
            updateFeatureList(newFeatures);
        });
    }

    // Function to update the feature list
    function updateFeatureList(features) {
        const featureList = d3.select("#feature-list");
        featureList.selectAll("*").remove(); // Clear previous features

        featureList.selectAll(".feature-item")
            .data(features)
            .enter()
            .append("div")
            .attr("class", d => d.type === "categorical" ? "feature-item categorical-feature" : "feature-item")
            .attr("draggable", true)
            .text(d => d.name)
            .on("dragstart", function (event, d) {
                event.dataTransfer.setData("feature", JSON.stringify(d));
            })
            .each(function (d) {
                if (d.type === "categorical") {
                    createCategoryDropdown(d3.select(this), d);
                }
            });
    }

    let selectedCategories = {}; // Store selected categories for each categorical feature

    function createCategoryDropdown(featureElement, feature) {
        if (!selectedCategories[feature.key]) {
            selectedCategories[feature.key] = new Set(); // Ensure each feature has its own selection set
        }

        const dropdown = d3.select("body").append("div")
            .attr("class", "category-dropdown")
            .style("display", "none")
            .style("position", "absolute")
            .style("background", "#f9f9f9")
            .style("border", "1px solid #ddd")
            .style("padding", "5px")
            .style("box-shadow", "0px 2px 5px rgba(0, 0, 0, 0.2)")
            .style("z-index", "1000");

        let isDropdownHovered = false;

        // Get unique categories from dataset
        const categories = [...new Set(dataset.map(d => d[feature.key]))];

        dropdown.selectAll(".category-item")
            .data(categories)
            .enter()
            .append("div")
            .attr("class", "category-item")
            .text(d => d)
            .style("padding", "3px 5px")
            .style("cursor", "pointer")
            .style("border-bottom", "1px solid #ddd")
            .style("background", d => selectedCategories[feature.key].has(d) ? "#d0e0ff" : "transparent") // Highlight selected categories
            .on("mouseenter", () => isDropdownHovered = true)
            .on("mouseleave", () => isDropdownHovered = false)
            .on("click", function (event, category) {
                event.stopPropagation(); // Prevent event bubbling

                if (selectedCategories[feature.key].has(category)) {
                    selectedCategories[feature.key].delete(category); // Deselect if already selected
                    d3.select(this).style("background", "transparent");
                } else {
                    selectedCategories[feature.key].add(category); // Select category
                    d3.select(this).style("background", "#d0e0ff"); // Highlight selection
                }

                console.log("Selected categories:", selectedCategories);
            });

        featureElement.on("mouseenter", function (event) {
            const rect = featureElement.node().getBoundingClientRect();
            dropdown.style("display", "block")
                .style("left", `${rect.left}px`)
                .style("top", `${rect.bottom}px`);
        });

        featureElement.on("mouseleave", function () {
            setTimeout(() => {
                if (!isDropdownHovered) dropdown.style("display", "none");
            }, 100);
        });

        dropdown.on("mouseleave", () => {
            isDropdownHovered = false;
            setTimeout(() => {
                if (!isDropdownHovered) dropdown.style("display", "none");
            }, 100);
        });
    }


    function applyCategoryFilter() {
        let filteredDataset = full_dataset; // Start with full dataset
        let filterCriteria = []; // Store filter details

        Object.keys(selectedCategories).forEach(featureKey => {
            if (selectedCategories[featureKey].size > 0) {
                filteredDataset = filteredDataset.filter(d => selectedCategories[featureKey].has(d[featureKey]));
                filterCriteria.push(`${featureKey}: ${[...selectedCategories[featureKey]].join(", ")}`);
            }
        });

        console.log("Filtered dataset:", filteredDataset);

        dataset = filteredDataset; // Overwrite the dataset with the filtered subset

        // Update filter message
        const filterMessage = document.getElementById("filter-message");
        if (filterCriteria.length > 0) {
            filterMessage.textContent = `Filtered by ${filterCriteria.join(" | ")}`;
        } else {
            filterMessage.textContent = "Full dataset"; // Clear message if no filters are applied
        }
    }

    function getActiveFilters() {
        let filterInfo = {};
        Object.keys(selectedCategories).forEach(featureKey => {
            if (selectedCategories[featureKey].size > 0) {
                filterInfo[featureKey] = [...selectedCategories[featureKey]]; // Convert Set to Array
            }
        });
        
        return filterInfo;
    }


    document.getElementById("apply-category-filter").addEventListener("click", applyCategoryFilter);

    // OpenAI API key 
    const API_KEY = '....';   // replace with api key
    let currentFormulaState = "";
    // function for getting ChatGPT responses
    function callOpenAI() {
        // Get the user's input from the input field
        const userInput = document.getElementById('userInput').value;

        // System prompt to enforce a strict format for the response
        let promptContext = `
            You are a helpful assistant for building statistical models. Always respond with the formulas in the exact format:
            Mean: y ~ x1 + x2
            SD: ~ 1
            Do not include any explanation or additional information.
        `;

        if (currentFormulaState) {
            promptContext += `The current formulas are:
            Mean: ${currentFormulaState.mean}
            SD: ${currentFormulaState.sd}
            Modify them based on the new input: "${userInput}". `;
        } else {
            promptContext += `Start new formulas based on the input: "${userInput}". `;
        }
    
        // The API URL for OpenAI
        const apiUrl = 'https://api.openai.com/v1/chat/completions';
    
        // Make the API request using the fetch function
        fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${API_KEY}`,
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini',  
                messages: [
                    { role: 'system', content: promptContext},
                    { role: 'user', content: userInput }
                ]
            })
        })
        .then(response => response.json())
        .then(data => {
            const output = data.choices[0].message.content.trim();

             // Extract mean and SD formulas from the output
            const meanMatch = output.match(/Mean:\s*(.+)/);
            const sdMatch = output.match(/SD:\s*(.+)/);

            const meanFormula = meanMatch ? meanMatch[1].trim() : "";
            const sdFormula = sdMatch ? sdMatch[1].trim() : "";

            // Update the current formula state with GPT's response
            currentFormulaState = { mean: meanFormula, sd: sdFormula };

            // Display the updated formulas
            document.getElementById('response').innerHTML = `
                <strong>Mean:</strong> ${meanFormula} <br>
                <strong>SD:</strong> ${sdFormula}
            `;

            // Update the input fields for formulas
            //document.getElementById('formulaMean').value = meanFormula;
            //document.getElementById('formulaStdDev').value = sdFormula;
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    async function matchHypotheses() {

        const meanFormula = document.getElementById('formulaMean').value;

        const formattedHypotheses = Object.values(hypothesesObject)
            .map(h => `ID: ${h.id}, Hypothesis: "${h.hypothesis}", Type: "${h.type}", TestType: "${h.testType}"`)
            .join("\n")
            
        // Get user input
        const userInput = document.getElementById('userInput').value;

        // Ensure the user entered a hypothesis
        if (!userInput.trim()) {
            console.log("Please enter a hypothesis to match.");
            return;
        }

        // Prepare prompt for ChatGPT
        const prompt = `
            You are an intelligent assistant. Compare the user's hypothesis to a list of hypotheses.
            Only return hypotheses that are similar to the user's input. 
            In order to be considered similar, all variables from the mean formula must appear in the hypothesis text from user.
            Also match the subset of word. For example, "ABC*DEF" and "DEF" are considered similar.
            Respond in the exact JSON format below:

            {
                "H1": {
                    "id": "H1",
                    "hypothesis": "Matching hypothesis text",
                    "type": "Main and Interaction",
                    "testType": "overall"
                },
                "H3": {
                    "id": "H3",
                    "hypothesis": "Matching hypothesis text",
                    "type": "Main and Interaction",
                    "testType": "overall"
                }
            }

            If no matches are found, return an empty object: {}

            User's hypothesis: "${userInput}"

            Hypotheses list:
            ${formattedHypotheses}

            Mean formula:
            ${meanFormula}
        `;

        // Call OpenAI API
        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_KEY}`,
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini', // Specify the model
                    messages: [{ role: 'user', content: prompt }]
                })
            });

            const data = await response.json();

            // Extract ChatGPT's response. Also remove triple ticks in case of no match
            const similarHypotheses = data.choices[0].message.content.trim().replace(/```json/g, "").replace(/```/g, "").trim();

            console.log(similarHypotheses)
            console.log(Object.keys(JSON.parse(similarHypotheses)).length)

            if (Object.keys(JSON.parse(similarHypotheses)).length == 0 ) {
                console.log("cannot find matching hypotheses");

                // send user input to chatgpt and ask for suggestion
                const meanFormula = document.getElementById('formulaMean').value;
                const stdFormula = document.getElementById('formulaStdDev').value;

                const suggestPrompt = `
                    You are a statistical consultant. The user input is a hypothesis the user wants to test using the regression model formula.
                    However, the hypothesis is cannot be answered using the current model formula because predictors that the user want to test is not included in the model.
                    
                    - User Input: "${userInput}"
                    - Model Mean Formula: "${meanFormula}"
                    - list of features: "${features}"

                    Suggest a model formula where the hypothesis can be tested.
                    Only use *, not : 
                    Don't do 3-way interaction
                    Suggest a 2-3 formulations, with one-sentence explanation of each (but don't inlcude the word 'Explanation').
                    Don't say anythibg else other than formula and explanation.
                    Formula and explanation should be separated by a full stop (.)
                    The suggested formulation have to include all predictors from meanFormula
                    
                `;

                const suggestResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`,
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{ role: 'user', content: suggestPrompt }]
                    })
                });

                const suggestData = await suggestResponse.json();
                const suggestedHypothesis = suggestData.choices[0].message.content.trim().replace(/\*\*/g, "").trim();

                //document.getElementById('hypothesis-logs').innerHTML = `<p style="color: black;"> ${suggestedHypothesis}</p>`;
                //return;

                // Split the response into separate model formulas
                const modelSuggestions = suggestedHypothesis.split(/\d+\.\s*Model Formula:/).filter(Boolean);

                // Select the div where the table will be displayed
                const modelContainer = document.getElementById('hypothesis-logs');
                modelContainer.innerHTML = ''; // Clear previous content

                // Create a table element
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.classList.add('hypothesis-table'); // Apply existing styles

                // Add a header row
                const headerRow = document.createElement('tr');
                ['Model Formula', 'Details'].forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    th.style.border = '1px solid #ccc';
                    th.style.padding = '8px';
                    th.style.backgroundColor = '#f4f4f4';
                    headerRow.appendChild(th);
                });
                table.appendChild(headerRow);

                // Add each suggested model as a row
                modelSuggestions.forEach((model, index) => {
                    const row = document.createElement('tr');

                    // Extract formula and explanation
                    const parts = model.split('. ', 2);
                    const formula = parts[0]?.trim() || "N/A";
                    const explanation = parts[1]?.trim() || "N/A";

                    const formulaCell = document.createElement('td');
                    formulaCell.textContent = formula;
                    formulaCell.style.border = '1px solid #ccc';
                    formulaCell.style.padding = '8px';
                    formulaCell.style.fontWeight = 'bold';

                    const explanationCell = document.createElement('td');
                    explanationCell.textContent = explanation;
                    explanationCell.style.border = '1px solid #ccc';
                    explanationCell.style.padding = '8px';

                    row.appendChild(formulaCell);
                    row.appendChild(explanationCell);
                    table.appendChild(row);
                });

                // Append the table to the output container
                modelContainer.appendChild(table);

            }

            const modelLogs = document.getElementById('hypothesis-logs');
            //modelLogs.innerHTML = '';

            let MainTable = modelLogs.querySelector('#hypothesisTable');
            //let MainTable = document.getElementById('hypothesisTable');
            if (!MainTable) {
                // Create the table if it doesn't exist

                MainTable = document.createElement('table');
                MainTable.id = 'hypothesisTable';
                //MainTable.id = `hypothesisTable-model${predCounter - 1}`;
                MainTable.style.width = '100%';
                MainTable.style.borderCollapse = 'collapse';
                MainTable.style.marginTop = '10px';

                // Add the CSS class for custom styling
                MainTable.classList.add('hypothesis-table');

                // Add a header row
                const headerRow = document.createElement('tr');
                ['Model','Hypothesis', 'Result','Adjusted','Vis','Status'].forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    th.style.border = '1px solid #ccc';
                    th.style.padding = '8px';
                    th.style.backgroundColor = '#f4f4f4';
                    headerRow.appendChild(th);
                });
                MainTable.appendChild(headerRow);

                document.getElementById('hypothesis-logs').appendChild(MainTable);
            }

            // Add rows for each hypothesis
            function addRow(hypothesis, id, testType) {
                const row = document.createElement('tr');
                //row.id = id; // Set the ID attribute
                row.id = id + `-model${predCounter - 1}`;
                row.setAttribute('test', testType); // Set the 'test' attribute

                // Model column
                const ModelCell = document.createElement('td');
                ModelCell.textContent = predCounter - 1;
                ModelCell.style.border = '1px solid #ccc';
                ModelCell.style.padding = '8px';
                row.appendChild(ModelCell);

                // Hypothesis column
                const hypothesisCell = document.createElement('td');
                hypothesisCell.style.border = '1px solid #ccc';
                hypothesisCell.style.padding = '8px';
                const words = hypothesis.split(' ');
                hypothesisCell.innerHTML = `<b>${words[0]}</b> ${words.slice(1, -1).join(' ')} <b>${words[words.length - 1]}</b>`;
                row.appendChild(hypothesisCell);

                // Type column
                /*
                const typeCell = document.createElement('td');
                typeCell.textContent = type;
                typeCell.style.border = '1px solid #ccc';
                typeCell.style.padding = '8px';
                row.appendChild(typeCell);
                */

                // Result column
                const resultCell = document.createElement('td');
                resultCell.style.border = '1px solid #ccc';
                resultCell.style.padding = '8px';

                // Add Test button in Result column
                const testButton = document.createElement('button');
                testButton.textContent = 'Test';
                testButton.style.padding = '5px 10px';
                testButton.style.fontSize = '12px';
                testButton.style.cursor = 'pointer';
                testButton.style.border = '1px solid #ccc';
                testButton.style.borderRadius = '5px';
                testButton.style.backgroundColor = '#D3D3D3'; 
                testButton.addEventListener('click', () => {
                    const clickedCell = event.target; // Get the clicked element

                    // retrive the model being tested
                    const modelNumber = row.cells[0].textContent.trim();
                    const radioButton = document.querySelector(`#model-${modelNumber}`);
                    radioButton.checked = true;

                    // update formula at the top to match the tested model
                    const meanInput = document.getElementById('formulaMean'); 
                    const stdDevInput = document.getElementById('formulaStdDev'); 
                    const distributionSelect = document.getElementById('distributionSelect'); 
                    meanInput.value = radioButton.dataset.mean;
                    stdDevInput.value = radioButton.dataset.stddev;
                    distributionSelect.value = radioButton.dataset.distribution;


                    const id = row.id; // Get the row's ID attribute
                    const modelIndexMatch = id.match(/model(\d+)/); // Extract predIndex from the table ID
                    const thisModelIndex = modelIndexMatch ? modelIndexMatch[1] : null;

                    const testType = row.getAttribute('test'); // Get the row's 'test' attribute
                    const hypothesis = row.cells[1].textContent.trim(); // Get hypothesis (second cell content)
                    const statusCell = row.cells[5];

                    testHypothesis(hypothesis, id, testType, thisModelIndex, resultCell, statusCell);
                });
                resultCell.appendChild(testButton);
                row.appendChild(resultCell);

                // Adjusted column
                const adjustedCell = document.createElement('td');
                adjustedCell.textContent = '';
                adjustedCell.style.border = '1px solid #ccc';
                adjustedCell.style.padding = '8px';

                // Add button to Adjusted column
                const adjustButton = document.createElement('button');
                adjustButton.textContent = 'Adjust';
                adjustButton.style.padding = '5px 10px';
                adjustButton.style.fontSize = '12px';
                adjustButton.style.cursor = 'pointer';
                adjustButton.style.border = '1px solid #ccc';
                adjustButton.style.borderRadius = '5px';
                adjustButton.style.backgroundColor = '#D3D3D3';
                adjustButton.addEventListener('click', () => {
                    const clickedCell = event.target; // Get the clicked element

                    const id = row.id; // Get the row's ID attribute
                    const modelIndexMatch = id.match(/model(\d+)/); // Extract predIndex from the table ID
                    const thisModelIndex = modelIndexMatch ? modelIndexMatch[1] : null;

                    const testType = row.getAttribute('test'); // Get the row's 'test' attribute
                    const hypothesis = row.cells[1].textContent.trim(); // Get hypothesis (second cell content)
                    const resultCell = row.cells[2]; 
                    const adjustCell = row.cells[3]; 
                    const statusCell = row.cells[6];
                    const pValueMatch = resultCell.textContent.match(/\(p-val\s*=\s*([\d.]+)\)/i);
                    const pValue = parseFloat(pValueMatch[1]);

                    console.log(pValue)

                    correctMultiple(pValue, testType, adjustCell);
                    //testHypothesis(hypothesis, id, testType, thisModelIndex, resultCell, statusCell);
                });
                adjustedCell.appendChild(adjustButton);

                row.appendChild(adjustedCell);

                // Vis column
                const visCell = document.createElement('td');
                //visCell.textContent = '';
                addSmallVis(visCell, testType, hypothesis);
                visCell.style.border = '1px solid #ccc';
                visCell.style.padding = '8px';
                row.appendChild(visCell);

                // Status column
                const statusCell = document.createElement('td');
                statusCell.textContent = 'New';
                statusCell.style.border = '1px solid #ccc';
                statusCell.style.padding = '8px';
                row.appendChild(statusCell);

                MainTable.appendChild(row);

                updateHypothesisCount();
            }

            function populateTable(data) {
                // Parse data if it's a string
                const parsedData = typeof data === 'string' ? JSON.parse(data) : data;

                // Ensure it's an object and process
                if (typeof parsedData === 'object' && parsedData !== null) {
                    Object.values(parsedData).forEach(item => {
                        //addRow(item.hypothesis, item.type, item.id, item.testType);
                        addRow(item.hypothesis, item.id, item.testType);
                    });
                    addTableEventListeners();

                } else {
                    console.error("Invalid data format. Expected an object:", parsedData);
                }
            }

            // update Status column
            if (document.querySelector('#hypothesisTable')) {
                updateStatusColumn();
            }

            
/*
            if (Object.keys(similarHypotheses).length === 14) {
                const meanFormula = document.getElementById('formulaMean').value;
                const modelLogs = document.getElementById('hypothesis-logs');
                
                modelLogs.innerHTML = `<p style="font-size: 14px; color: blue;">
                    No matching hypotheses found. Using mean formula: <strong>${meanFormula}</strong>
                </p>`;
            }
             
            // add rows to table
            populateTable(similarHypotheses);
            */

            // Check if a message already exists
        let existingMessage = document.getElementById('no-match-message');
        if (!existingMessage) {
            existingMessage = document.createElement('p');
            existingMessage.id = 'no-match-message';
            existingMessage.style.fontSize = '14px';
            existingMessage.style.color = 'blue';
            existingMessage.style.marginBottom = '10px';
            modelLogs.prepend(existingMessage);
        }

        if (Object.keys(similarHypotheses).length === 14) {
            const meanFormula = document.getElementById('formulaMean').value;
            const userInput = document.getElementById('userInput').value.trim(); 

            existingMessage.innerHTML = `
            No matching hypotheses found. <br>
            Try mean formula: <strong>${meanFormula} + ${userInput}</strong>
            `;
        } else {
            existingMessage.innerHTML = ''; // Clear message when matches are found
            populateTable(similarHypotheses);
        }
            

            // sort rows
            const customOrder = ["New", "Tested", "Untested"]; // Define the custom order
            sortTableByCustomOrder("hypothesisTable", 5, 0, customOrder, true);

            // Append the table to the model log area
            //modelLogs.appendChild(MainTable);


            // Add click event listeners to all rows in the table
            document.querySelectorAll('#hypothesisTable tr').forEach(row => {
            //document.querySelectorAll('[id^="hypothesisTable"] tr').forEach(row => {    
                row.addEventListener('click', () => {

                    //const tableId = row.closest('table').id; // Get the table's ID
                    //const modelIndexMatch = tableId.match(/model(\d+)/); // Extract predIndex from the table ID
                    //const thisModelIndex = modelIndexMatch[1];

                    const clickedCell = event.target; // Get the clicked element
                    const isHypothesisColumn = row.cells[1] === clickedCell; // Check if it's the second cell
                    const isVisColumn = row.cells[4] === clickedCell;

                    const id = row.id; // Get the row's ID attribute
                    const modelIndexMatch = id.match(/model(\d+)/); // Extract predIndex from the table ID
                    const thisModelIndex = modelIndexMatch[1];
                    
                    const testType = row.getAttribute('test'); // Get the row's 'test' attribute
                    const hypothesis = row.cells[1].textContent.trim(); // Get hypothesis (second cell content)
                    const resultCell = row.cells[2];
                    const statusCell = row.cells[5];

                    if (isHypothesisColumn) {
                        //testHypothesis(hypothesis, id, testType, thisModelIndex, resultCell, statusCell);
                    } else if (isVisColumn) {
                        console.log(isVisColumn)
                        createHypoVis(hypothesis, testType);
                    }
                });
            });


        } catch (error) {
            console.error("Error while matching hypotheses:", error);
        }
    }

    

    // Counter for unique Prediction
    let predCounter = 1;

    // Model Fitting in R
    document.getElementById('fit-model-button').addEventListener('click', async () => {

        const formulaMean = document.getElementById('formulaMean').value.trim();
        const formulaStdDev = document.getElementById('formulaStdDev').value.trim();
        const selectedDistribution = document.getElementById('distributionSelect').value; 
        const distributionText = document.getElementById("distributionSelect")
            .options[document.getElementById("distributionSelect").selectedIndex].text;
        const filters = getActiveFilters(); // Get selected filter information
        console.log("filters: "+JSON.stringify(filters))
        createHypoObj();

        // Validate inputs
        if (!formulaMean || !formulaStdDev) {
            document.getElementById('hypothesis-logs').textContent = 'Please provide both formulas.';
            return;
        }

        // Normalize formula input by removing extra spaces
        const normalizedFormula = formulaMean.replace(/\s+/g, '');
        const normalizedStdDev = formulaStdDev.replace(/\s+/g, '');
    
        // Check for duplicates (if the formula was fitted before)
        let isDuplicate = false;
        document.querySelectorAll('input[name="model-selection"]').forEach((radio) => {
            let existingFormula = radio.dataset.mean?.replace(/\s+/g, '') || "";
            let existingStdDev = radio.dataset.stddev?.replace(/\s+/g, '') || "";
            let existingDistribution = radio.dataset.distribution || "";
    
            if (
                existingFormula === normalizedFormula &&
                existingStdDev === normalizedStdDev &&
                existingDistribution === selectedDistribution
            ) {
                isDuplicate = true;
            }
        });
    
        // Function to normalize formulas by ensuring proper spacing around operators
        function normalizeFormula(formula) {
            return formula
                .replace(/\s*([~+*])\s*/g, ' $1 ')  
                .replace(/\s+/g, ' ')               
                .trim();                            
        }

        
        if (isDuplicate) {
            alert("This formulation already exists.");
        
            // Find the matching radio button and select it
            document.querySelectorAll('input[name="model-selection"]').forEach((radio) => {
                let storedMean = normalizeFormula(radio.dataset.mean || '');
                let storedStdDev = normalizeFormula(radio.dataset.stddev || '');
                let storedDistribution = radio.dataset.distribution?.trim() || '';
        
                let normalizedFormulaMean = normalizeFormula(formulaMean);
                let normalizedFormulaStdDev = normalizeFormula(formulaStdDev);
        

        
                if (
                    storedMean === normalizedFormulaMean &&
                    storedStdDev === normalizedFormulaStdDev &&
                    storedDistribution === selectedDistribution.trim()
                ) {
                    
                    // Select the existing radio button
                    radio.checked = true;  
        
                    // Manually trigger change event
                    radio.dispatchEvent(new Event('change'));
        
                    // Find the model entry
                    const modelEntry = radio.closest('.model-entry');
      
                    // Expand the corresponding model
                    const formulaDetails = modelEntry.querySelector('.formula-details');
                    const expandIcon = modelEntry.querySelector('.expand-icon');
        
                    if (formulaDetails) {
                        formulaDetails.style.display = 'block'; // Expand details
                    } 
        
                    if (expandIcon) {
                        console.log("Rotating arrow for model:", radio.value);
                    } 
                }
            });
        
            return; // Stop execution if duplicate is found
        }

        // Sending a POST request to the Plumber API
        try {
            const response = await fetch('http://localhost:8000/fit_model', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                    formula_mean: formulaMean,
                    formula_std_dev: formulaStdDev,
                    distribution: selectedDistribution,
                    datasetName: current_dataset,
                    filters: filters
                })
            });

            const data = await response.json();
            
            if (data.success) {
                //globalDeviance = data.global_deviance;
                aic = data.aic;
                rsq = data.rsq;
                
                const HypoLogs = document.getElementById('Model-List');

                // Create model container (with shadow and border)
                const modelContainer = document.createElement('div');
                modelContainer.className = 'model-entry';
                modelContainer.setAttribute('model-index', predCounter);
                
                // Create model header (row layout)
                const modelHeader = document.createElement('div');
                modelHeader.className = 'model-header';
                
                const expandIcon = document.createElement('img');
                expandIcon.src = 'arrow_right.svg'; // Default right arrow
                expandIcon.alt = 'Expand';
                expandIcon.className = 'expand-icon';
                expandIcon.style.width = '10px'; // Adjust size as needed
                expandIcon.style.cursor = 'pointer';
                
                // Expand button
                expandIcon.addEventListener('click', () => {
                    const isExpanded = formulaDetails.style.display === 'block';
                    formulaDetails.style.display = isExpanded ? 'none' : 'block';
                    expandIcon.classList.toggle('rotate-arrow'); // Toggle rotation class
                });

                
                // Model title
                const modelTitle = document.createElement('span');
                modelTitle.textContent = `Model ${predCounter}`;

                function updateInputFields(selectedRadio) {
                    // Find the input fields at the top of the page
                    const meanInput = document.getElementById('formulaMean'); 
                    const stdDevInput = document.getElementById('formulaStdDev'); 
                    const distributionSelect = document.getElementById('distributionSelect'); 
                
                    if (meanInput && stdDevInput && distributionSelect) {
                        meanInput.value = selectedRadio.dataset.mean;
                        stdDevInput.value = selectedRadio.dataset.stddev;
                        distributionSelect.value = selectedRadio.dataset.distribution;
                    }
                }
                
                // Radio button
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'model-selection';
                radio.value = `Model ${predCounter}`;
                radio.id = `model-${predCounter}`;

                radio.checked = true; // Automatically select the newly added model
                
                // Store the model data for easy retrieval
                radio.dataset.mean = formulaMean;
                radio.dataset.stddev = formulaStdDev;
                radio.dataset.distribution = document.getElementById('distributionSelect').value;
                
                updateInputFields(radio);
                
                // Append elements in row order
                modelHeader.appendChild(expandIcon);
                modelHeader.appendChild(modelTitle);
                modelHeader.appendChild(radio);

                // Listen for selection changes
                radio.addEventListener('change', function () {
                    updateInputFields(this);
                        // Expand the model details when selected
                        const modelEntry = this.closest('.model-entry');
                        const formulaDetails = modelEntry.querySelector('.formula-details');
                        const expandIcon = modelEntry.querySelector('.expand-icon');
                    
                        formulaDetails.style.display = 'block'; // Show details
                        expandIcon.classList.add('rotate-arrow'); // Rotate the arrow
                });
                
                // Create formula details (hidden by default)
                const formulaDetails = document.createElement('div');
                formulaDetails.className = 'formula-details';
                formulaDetails.style.display = 'none';
                formulaDetails.innerHTML = `
                    <p style="margin: 0;"><strong>Mean:</strong> ${formulaMean}</p>
                    <p style="margin: 0;"><strong>SD:</strong> ${formulaStdDev}</p>
                    <p style="margin-top: 0;"><strong>Distribution:</strong> ${distributionText}</p>
                    <p style="margin: 0;"><strong>AIC:</strong> ${aic}, <strong>R:</strong> ${rsq}</p>
                `;
                
                // Append the header and details to the model container
                modelContainer.appendChild(modelHeader);
                modelContainer.appendChild(formulaDetails);
                
                // Append model container to Model-List section
                HypoLogs.appendChild(modelContainer);


                // Add click event for the model
                /*
                formulaLog.querySelector('.clickable-model').addEventListener('click', function () {
                    const [yVar, xVars] = formulaMean.split('~').map(v => v.trim());
                    const modelIndex = this.getAttribute('prediction-index');
                    const predictedFeatureKey = `pred${modelIndex}_1`; // 

                    showPredict(yVar, predictedFeatureKey, modelIndex)
                });
                */
                const predPrefix = `pred${predCounter}_`; // Prefix for the prediction columns
                const predictedFeatureNames = []; // To store feature names for the UI

                // loop through 5 draws
                for (let i = 1; i <= 5; i++) {
                    const predColumn = `${predPrefix}${i}`;
                    const predictedFeatureName = `Predicted (${predCounter})`;
                    const residualColumn = `residual${predCounter}_${i}`;
                    const residualFeatureName = `Residual (${predCounter})`;

                    // Update the dataset with new predictions
                    dataset.forEach((d, index) => {
                        d[predColumn] = +data.result[index][predColumn];
                        //d[residualColumn] = d["Life_expectancy"] - d[predColumn];
                        d[residualColumn] = d[features[0].key] - d[predColumn]; // Assuming first feature is outcome 
                    });
                    
                    // Create a new draggable feature for each prediction
                    const predictedFeature = {
                        name: predictedFeatureName,
                        key: predColumn,
                        type: "continuous"
                    };

                    const residualFeature = { 
                        name: residualFeatureName, 
                        key: residualColumn, 
                        type: "continuous" 
                    };

                    features.push(predictedFeature);
                    features.push(residualFeature);

                    if (i == 1) {
                        // Add the new feature to the UI
                        d3.select("#feature-list")
                            .append("div")
                            .attr("class", "feature-item prediction-item")
                            .attr("draggable", true)
                            .text(predictedFeature.name)
                            .on("dragstart", function (event) {
                                event.dataTransfer.setData("feature", JSON.stringify(predictedFeature));
                            });

                        d3.select("#feature-list")
                            .append("div")
                            .attr("class", "feature-item residual-item")
                            .attr("draggable", true)
                            .text(residualFeature.name)
                            .on("dragstart", function (event) {
                                event.dataTransfer.setData("feature", JSON.stringify(residualFeature));
                            });
                    }

                }
                console.log(features)
                console.log(dataset)

                // Increment the counter after generating the names
                predCounter++;

            } else {
                document.getElementById('hypothesis-logs').textContent = `Error: ${data.error}`;
            }
        } catch (error) {
            document.getElementById('hypothesis-logs').textContent = `Network error: ${error.message}`;
        }
    });

    
    // Make the formula textbox a drop area
    const formulaTextboxMean = document.getElementById('formulaMean');
    const formulaTextboxSigma = document.getElementById('formulaStdDev');

    formulaTextboxMean.addEventListener('dragover', (event) => {
        // Allow the drop
        event.preventDefault();
    });

    formulaTextboxSigma.addEventListener('dragover', (event) => {
        // Allow the drop
        event.preventDefault();
    });

    formulaTextboxMean.addEventListener('drop', (event) => {
        // Prevent default behavior
        event.preventDefault();

        // Retrieve the dropped feature's data
        const feature = JSON.parse(event.dataTransfer.getData('feature'));

        // Append the feature key to the current text in the textbox
        formulaTextboxMean.value += formulaTextboxMean.value ? `${feature.key}` : `${feature.key} ~`;
    });

    formulaTextboxSigma.addEventListener('drop', (event) => {
        // Prevent default behavior
        event.preventDefault();

        // Retrieve the dropped feature's data
        const feature = JSON.parse(event.dataTransfer.getData('feature'));

        // Append the feature key to the current text in the textbox
        formulaTextboxSigma.value += formulaTextboxSigma.value ? ` ${feature.key}` : `${feature.key} ~`;
    });

    
    // Set up drop area
    const dropArea = d3.select("#drop-area");
    dropArea.style("display", "flex")
        .style("flex-wrap", "wrap") // Allows charts to move to the next line
        .on("dragover", event => event.preventDefault())
        .on("drop", function(event) {
            event.preventDefault();
            const feature = JSON.parse(event.dataTransfer.getData("feature"));
            renderPlot(feature);
        });

    // Render plots based on feature type
    function renderPlot(feature) {
        const chartId = `chart-${feature.key}-${Date.now()}`;
        const plotContainer = dropArea.append("div")
            .attr("class", "plot-container")
            .attr("id", chartId) 
            .attr("draggable", true)
            .style("position", "relative")
            .style("width", "200px")
            .style("height", "200px")
            .style("margin", "20px")
            .attr("data-feature", feature.key)  // Store feature key for combining
            .on("dragstart", function(event) {
                event.dataTransfer.setData("draggedFeature", JSON.stringify(feature));
                event.dataTransfer.setData("chartId", chartId);
            })
            .on("dragover", event => event.preventDefault())
            .on("drop", function(event) {
                event.preventDefault();
                const draggedFeature = JSON.parse(event.dataTransfer.getData("draggedFeature"));
                const draggedChartId = event.dataTransfer.getData("chartId");
                const targetFeatureKey = d3.select(this).attr("data-feature");
                const targetFeature = features.find(f => f.key === targetFeatureKey);

                combinePlots(draggedFeature, targetFeature, this, draggedChartId);
            })
            .node();

            // **Append dataset status label**
            d3.select(plotContainer).append("div")
                .attr("class", "dataset-status")
                .style("text-align", "center")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .style("margin-bottom", "5px")
                .text(document.getElementById("filter-message").textContent); 

       
        if (feature.type === "continuous") {
            renderDistributionPlot(plotContainer, feature.key, feature.name);
        } else if (feature.type === "categorical") {
            renderBarChart(plotContainer, feature.key, feature.name);
        }

        

    }

    // Generate Distribution Plot for Continuous Features
    function renderDistributionPlot(container, featureKey, featureName) {

        container = d3.select(container)
        const size = 200;
        const margin = { top: 10, right: 10, bottom: 40, left: 40 };
        const width = size - margin.left - margin.right;
        const height = size - margin.top - margin.bottom;

        const isPrediction = featureKey.startsWith('pred'); // Check for prediction features
        const isResidual = featureKey.startsWith('residual');
        const pointColor = isPrediction ? predictChart_col : (isResidual ? residual_col : baseChart_col);


        // Set the plot type as distribution
        container.attr("data-plot-type", "distribution")
                 //.attr("id", chartId);

        // Preprocess the dataset for the specified feature
        const mappedData = dataset.map((d, i) => ({
            value: +d[featureKey], // Convert feature to numeric
            index: i               // Attach the original index
        }));

        const x = d3.scaleLinear()
            .domain(d3.extent(mappedData, d => d.value)) // Use the extent of the feature values
            .nice()
            .range([margin.left, size - margin.right]);        

        const bins = d3.histogram()
            .domain(x.domain())
            .thresholds(10)
            .value(d => d.value)(mappedData);

        bins.forEach((bin, i) => {
            bin.indices = bin.map(d => d.index); // Add indices for linking
        });
        
        const y = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).nice().range([size - margin.bottom, margin.top]);

        const svg = container.append("svg")
            .attr("width", size)
            .attr("height", size)
            .attr("class", "distribution-plot");

        if (featureKey.startsWith('residual')) {
            svg.append("line")
                .attr("x1", x(0))
                .attr("x2", x(0))
                .attr("y1", margin.top)
                .attr("y2", size - margin.bottom)
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "4 2"); // Dashed line
        }

        // Draw histogram bars
        svg.append("g")
            .selectAll("rect")
            .data(bins)
            .enter().append("rect")
            .attr("x", d => x(d.x0) + 1)
            .attr("y", d => y(d.length))
            .attr("width", d => x(d.x1) - x(d.x0) - 1)
            .attr("height", d => y(0) - y(d.length))
            .attr("fill", pointColor)
            .attr("class", "histogram-bar")
            .attr("data-bin-indices", d => JSON.stringify(d.indices)); // Attach indices for linking
            
        // X-axis
        svg.append("g")
            .attr("transform", `translate(0,${size - margin.bottom})`)
            .call(d3.axisBottom(x).tickSize(3).ticks(5));
        
        // Y-axis
        svg.append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(y).tickSize(3).ticks(5));

        // X-axis label
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("x", width / 2 + margin.left)
            .attr("y", size - 5)
            .text(featureName);

        // Y-axis label
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("x", -height / 2 - margin.top)
            .attr("y", 15)
            .text("Frequency");

        // Add remove button
        addRemoveButton(container);
    }

    let currentHoveredBar = null; // Track the currently hovered bar

    // Generate Bar Chart for Categorical Features (one variable)
    function renderBarChart(container, featureKey, featureName) {
        container = d3.select(container);
        const size = 200;
        const margin = { top: 10, right: 10, bottom: 40, left: 40 };
        const width = size - margin.left - margin.right;
        const height = size - margin.top - margin.bottom;

        container.attr("data-plot-type", "barchart");
        
        const data = d3.rollups(
            dataset,
            v => ({
                count: v.length,
                indices: v.map((_, idx) => dataset.indexOf(v[idx])) // Use the original dataset index
            }),
            d => d[featureKey]
        ).map(([key, value]) => ({ category: key, ...value }));

        const x = d3.scaleBand()
            .domain(data.map(d => d.category))
            .range([margin.left, size - margin.right])
            .padding(0.1);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.count)])
            //.nice()
            .range([size - margin.bottom, margin.top]);

        const svg = container.append("svg")
            .attr("class", "bar-chart")
            .attr("data-feature", featureKey)
            .attr("width", size)
            .attr("height", size);

        let hoverIndices = new Set();
        
        // Draw background bars for the full dataset
        svg.selectAll(".background-bar")
            .data(data)
            .enter()
            .append("rect")
            .attr("class", "background-bar")
            .attr("x", d => x(d.category))
            .attr("y", d => y(d.count))
            .attr("width", x.bandwidth())
            .attr("height", d => y(0) - y(d.count))
            .attr("fill", "#c7c7c7") // Gray color for background bars
            .attr("data-indices", d => JSON.stringify(d.indices)) // Store indices for hover interaction
            .on("mouseover", function (event, d) {
                // Track the currently hovered bar
                currentHoveredBar = this;
                
                // Change bar color to orange
                d3.select(this).attr("fill", brush_col);

                
                // Indices of the hovered bar
                const hoveredIndices = new Set(d.indices);

                // Update the global highlightedIndices
                highlightedIndices = hoveredIndices;

                // Highlight respective points in scatterplots
                d3.selectAll(".scatter-plot .scatter-point")
                    .style("fill", function () {
                        const pointIndex = +d3.select(this).attr("data-index");

                        // Highlight points matching the hovered bar
                        if (hoveredIndices.has(pointIndex)) {
                            return brush_col;
                        }

                         // Determine the original color of non-hovered points
                        const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-other-feature");
                        const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature");

                        return featureKeyX.startsWith("pred") || featureKeyY.startsWith("pred")
                            ? predictChart_col // Predicted variable color
                            : baseChart_col; // Default scatterplot color

                    });

                // Update highlighted bars in other bar charts
                d3.selectAll(".bar-chart").each(function () {
                    const barSvg = d3.select(this);
                    const categoricalFeature = barSvg.attr("data-feature");

                    // Skip the hovered chart
                    if (categoricalFeature === featureKey) return;

                    // Subset data for this bar chart
                    const filteredData = dataset.filter((_, i) => hoveredIndices.has(i));
                    const subset = d3.rollups(
                        filteredData,
                        v => v.length,
                        d => d[categoricalFeature]
                    ).map(([key, value]) => ({ category: key, count: value }));

                    // Get affected chart's data and categories
                    const affectedData = barSvg.selectAll(".background-bar").data();
                    const affectedCategories = affectedData.map(d => d.category);

                    // Align subset data with affected chart categories
                    const subsetComplete = affectedCategories.map(category => {
                        const found = subset.find(d => d.category === category);
                        return { category, count: found ? found.count : 0 };
                    });

                    const xAffected = d3.scaleBand()
                        .domain(affectedCategories)
                        .range([margin.left, size - margin.right])
                        .padding(0.1);

                    const yAffected = d3.scaleLinear()
                        .domain([0, d3.max(affectedData, d => d.count)])
                        .range([size - margin.bottom, margin.top]);

                    // Update highlighted bars
                    barSvg.selectAll(".highlighted-bar")
                        .data(subsetComplete, d => d.category)
                        .join(
                            enter => enter.append("rect")
                                .attr("class", "highlighted-bar")
                                .attr("x", d => xAffected(d.category))
                                .attr("y", d => yAffected(d.count))
                                .attr("width", xAffected.bandwidth())
                                .attr("height", d => size - margin.bottom - yAffected(d.count))
                                .attr("fill", brush_col)
                                .style("opacity", 0.7),
                            update => update
                                .attr("x", d => xAffected(d.category))
                                .attr("y", d => yAffected(d.count))
                                .attr("width", xAffected.bandwidth())
                                .attr("height", d => size - margin.bottom - yAffected(d.count)),
                            exit => exit.remove()
                        );
                });

            })
            .on("mouseout", function (event, d) {
                // Reset bar color to gray
                d3.select(this).attr("fill", "#c7c7c7");

                // Clear global highlightedIndices
                highlightedIndices.clear();

                // Clear the hovered bar reference
                currentHoveredBar = null;
                
                // Reset scatterplot points to default color
                d3.selectAll(".scatter-plot .scatter-point")
                    .style("fill", function () {
                        const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-other-feature");
                        const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature");

                        // Determine original color
                        return featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred')
                            ? predictChart_col // Predicted variable color
                            : baseChart_col; // Default color
                    });

                // Clear highlighted bars in all bar charts
                d3.selectAll(".bar-chart").selectAll(".highlighted-bar").remove();
            });

        // X-axis
        const xAxis = svg.append("g")
            .attr("transform", `translate(0,${size - margin.bottom})`)
            .call(d3.axisBottom(x).tickSize(3));

        // Count the number of categories
        const numCategories = data.length;

        // Rotate tick labels if necessary
        /*
        xAxis.selectAll("text")
            .attr("text-anchor", "end")
            .attr("dx", "0.7em")
            .attr("dy", "0.40em")
            .attr("transform", function () {
                return this.textContent.length > 2 ? "rotate(-20)" : "";
            });
*/
        xAxis.selectAll("text")
        .attr("text-anchor", numCategories > 4 ? "end" : "middle") // Rotate only if more than 4 categories
        .attr("dx", numCategories > 4 ? "0.7em" : "0") 
        .attr("dy", numCategories > 4 ? "0.40em" : "0.35em")
        .attr("transform", function () {
            return numCategories > 4 ? "rotate(-20)" : ""; // Rotate only when necessary
        });

        // Y-axis
        svg.append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(y).tickSize(2).ticks(5));

        // X-axis label
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("x", width / 2 + margin.left)
            .attr("y", size - 5)
            .text(featureName);

        // Y-axis label
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("x", -height / 2 - margin.top)
            .attr("y", 15)
            .text("Count");

        // Add remove button
        addRemoveButton(container);
    }

    // check whether this feature is categorical
    function isCategorical(data, featureKey) {
        const uniqueValues = [...new Set(data.map(d => d[featureKey]))];
        return uniqueValues.some(v => typeof v === 'string');
    }

    function combinePlots(feature1, feature2, targetContainer, draggedChartId) {
        
        // Check if both features are the same, do not merge
        if (feature1.key === feature2.key) {
            return;
        }

        const isFeature1Continuous = feature1.type === "continuous";
        const isFeature2Continuous = feature2.type === "continuous";

        // Remove the dragged chart container
        
        const draggedFeatureKey = feature1.key;

        if (draggedChartId) {
            d3.select(`#${draggedChartId}`).remove();
        }
        // Clear existing plots in the container
        d3.select(targetContainer).selectAll("*").remove();

        // **Re-add dataset status label after merging**
        d3.select(targetContainer)
            .append("div")
            .attr("class", "dataset-status")
            .style("text-align", "center")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("margin-bottom", "5px")
            .text(document.getElementById("filter-message").textContent);
        

        if (isFeature1Continuous && isFeature2Continuous) {

            renderScatterPlot(targetContainer, feature1.key, feature2.key, feature1.name, feature2.name);
        
        } else if (isFeature1Continuous && !isFeature2Continuous) {
          
            renderAverageBarChart(targetContainer, feature2.key, feature1.key, feature2.name, feature1.name);
        
        } else if (!isFeature1Continuous && isFeature2Continuous) {
           
            renderAverageBarChart(targetContainer, feature1.key, feature2.key, feature1.name, feature2.name);

        } else {
            alert("Cannot combine two categorical variables");
        }

        
    }

    let highlightedIndices = new Set();

    // Render Scatter Plot for Continuous Features
    function renderScatterPlot(container, featureX, featureY, featureX_Name, featureY_Name, dataSubset = dataset, classFeature = null, colorScale = null) {
        

        // only update highlight if it's not hypo vis
        if (colorScale == null) {
            updateHighlights(classFeature, colorScale)
        }

        visualizationMappings.push({ x: featureX, y: featureY });

        const size = 200;
        const margin = { top: 10, right: 10, bottom: 40, left: 40 };
        const width = size - margin.left - margin.right;
        const height = size - margin.top - margin.bottom;

        const isPrediction = featureX.startsWith('pred') || featureY.startsWith('pred'); // Check for prediction features
        const isResidual = featureX.startsWith('residual') || featureY.startsWith('residual');

        const pointColor = isResidual 
            ? residual_col 
            : (isPrediction ? predictChart_col : baseChart_col);

        // Set the plot type as scatterplot
        d3.select(container).attr("data-plot-type", "scatterplot")
                 .attr("data-other-feature", featureX) // Store the non-predicted feature
                 //.attr("id", chartId);

        const x = d3.scaleLinear()
            .domain(d3.extent(dataSubset, d => +d[featureX]))
            .range([margin.left, width + margin.left]);
        
        const y = d3.scaleLinear()
            .domain(d3.extent(dataSubset, d => +d[featureY]))
            .range([height + margin.top, margin.top]);

        const svg = d3.select(container)
            .append("svg")
            .attr("width", size)
            .attr("height", size)
            .attr("class", "scatter-plot"); // Add class for identification

        if (featureY.startsWith('residual')) {
            svg.append("line")
                .attr("x1", margin.left)
                .attr("x2", width + margin.left)
                .attr("y1", y(0))
                .attr("y2", y(0))
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "4 2"); // Dashed line
        }

        // Create a group for the points
        const pointsGroup = svg.append("g")
            .attr("class", "points-group");

        // sort by brightness if there are multiple colors
        const sortedData = (classFeature && colorScale) 
            ? dataSubset.sort((a, b) => d3.hsl(colorScale(a[classFeature])).l - d3.hsl(colorScale(b[classFeature])).l) 
            : dataSubset;

        // Create circles for scatterplot
        const circles = pointsGroup.selectAll("circle")
            //.data(dataSubset)
            .data(sortedData)
            .enter()
            .append("circle")
            .attr("class", "scatter-point")  // Add class for easier selection
            .attr("cx", d => x(d[featureX]))
            .attr("cy", d => y(d[featureY]))
            .attr("r", 3)
            //.attr("fill", pointColor)
            .attr("fill", d => (classFeature && colorScale) ? colorScale(d[classFeature]) : pointColor)
            .attr("data-original-color", d => { // Store color for later use
                return (classFeature && colorScale) ? colorScale(d[classFeature]) : pointColor;
            })
            .attr("opacity", 0.5)
            .attr("data-index", (d, i) => i);  // Store index for linking

        // Create brush behavior
        const brush = d3.brush()
            .extent([[0, 0], [size, size]])
            .on("start", brushStarted)
            .on("brush", brushed)
            .on("end", brushEnded);

        // Add brush to a new group
        svg.append("g")
            .attr("class", "brush")
            .call(brush);

        // Create axes
        const xAxis = d3.axisBottom(x).tickSize(3);
        const yAxis = d3.axisLeft(y).tickSize(2); 

        // Append axes
        const gX = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height + margin.top})`)
            .call(xAxis);

        const gY = svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", `translate(${margin.left},0)`)
            .call(yAxis);

        // Add labels
        const xLabel = svg.append("text")
            .attr("text-anchor", "middle")
            .attr("x", width / 2 + margin.left)
            .attr("y", size - 5)
            .text(featureX_Name);

        const yLabel = svg.append("text")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("x", -height / 2)
            .attr("y", 15)
            .text(featureY_Name);

        // Add remove button
        addRemoveButton(d3.select(container));
        addTestButton(d3.select(container));

        let zoomedData = dataSubset; // Store the zoomed dataset
        let isZoomed = false; // Flag to track zoom state

        const zoomButton = d3.select(container)
            .append("button")
            .text("")
            .attr("class", "zoom-button")
            .style("position", "absolute")
            .style("top", "4px")
            .style("right", "4px")
            .style("font-size", "10px")
            .style("cursor", "pointer")
            .style("padding", "3px 6px")
            .style("border", "1px solid #ccc")
            .style("border-radius", "4px")
            .style("background", "#eee")
            .on("click", zoomToBrushed);

        // Add a "Flip Axes" button
        const flipButton = d3.select(container)
            .append("button")
            //.text("Flip")
            .html('<img src="icon_flip.svg" width="10" height="10" alt="Flip Icon">')
            .attr("class", "flip-button")
            .style("position", "absolute")
            .style("top", "180px")
            .style("left", "10px")
            .style("z-index", 10) // Ensure it appears above other elements
            .on("click", () => {
                // Clear the existing brush rectangle
                svg.select(".brush").call(brush.move, null);
                
                // Swap featureX and featureY
                [featureX, featureY] = [featureY, featureX];
                [featureX_Name, featureY_Name] = [featureY_Name, featureX_Name];

                // Update scales
                x.domain(d3.extent(dataSubset, d => +d[featureX]));
                y.domain(d3.extent(dataSubset, d => +d[featureY]));

                // Update axes
                gX.transition().call(xAxis.scale(x));
                gY.transition().call(yAxis.scale(y));

                // Update axis labels
                xLabel.text(featureX_Name);
                yLabel.text(featureY_Name);

                // Update points
                pointsGroup.selectAll("circle")
                    //.transition()
                    .attr("cx", d => x(d[featureX]))
                    .attr("cy", d => y(d[featureY]));
            });

        function brushStarted(event) {
            // If no valid event or source event, exit the function
            if (!event.sourceEvent) return;

            // If this brush is starting, clear all other brushes
            const currentBrush = event.sourceEvent.target;
            
            d3.selectAll(".brush").each(function() {
                // Skip the current brush
                if (this !== currentBrush.parentNode) {
                    // Clear the brush
                    d3.select(this).call(brush.move, null);
                }
            });
        }

        function brushed(event) {
            if (!event.selection) return; // Skip if no selection
            
            // Get the brush selection coordinates
            const [[x0, y0], [x1, y1]] = event.selection;
            
            // Clear the global highlightedIndices
            highlightedIndices.clear();

            zoomedData = dataSubset.filter(d => {
                const cx = x(d[featureX]);
                const cy = y(d[featureY]);
                return cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1;
            });

            // Update highlight
            //pointsGroup.selectAll(".scatter-point").attr("opacity", d => zoomedData.includes(d) ? 1 : 0.2);

            zoomButton.style("background", zoomedData.length > 0 ? "#d3d3d3" : "#eee");

            pointsGroup.selectAll(".scatter-point").each(function(d, i) {
                const circle = d3.select(this);
                const cx = +circle.attr("cx");
                const cy = +circle.attr("cy");
                
                if (cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1) {
                    highlightedIndices.add(i);
                }
            });

            // Update the visual highlights
            updateHighlights();

        }

        function brushEnded(event) {
            if (!event.selection) {
                zoomedData = dataSubset;
                zoomButton.style("background", "#eee");
                // If no selection, reset all points across all plots
                d3.selectAll(".scatter-plot .scatter-point")
                    .style("fill", function () {
                        const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-other-feature");
                        const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature");

                        let originalColor = d3.select(this).attr("data-original-color");

                        // Determine original color
                        return featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred')
                            ? predictChart_col // Predicted variable color
                            : originalColor; // original color
                    });

                // Clear frequency highlights
                d3.selectAll(".highlighted-bar.frequency").remove();

                // Reset average bars to the full dataset
                d3.selectAll(".bar-chart").each(function () {
                    const barSvg = d3.select(this);
                    const categoricalFeature = barSvg.attr("data-feature");
                    const continuousFeature = barSvg.attr("data-continuous-feature");

                    if (continuousFeature) {
                        // Compute averages for the full dataset
                        const fullDataAverages = d3.rollups(
                            dataSubset,
                            v => d3.mean(v, d => +d[continuousFeature]),
                            d => d[categoricalFeature]
                        ).map(([key, value]) => ({ category: key, average: value || 0 }));

                        const allCategories = fullDataAverages.map(d => d.category);

                        const margin = { top: 10, right: 10, bottom: 40, left: 40 };
                        const size = 200;

                        const x = d3.scaleBand()
                            .domain(allCategories)
                            .range([margin.left, size - margin.right])
                            .padding(0.1);

                        const yAverage = d3.scaleLinear()
                            .domain([0, d3.max(fullDataAverages, d => d.average) || 1])
                            .range([size - margin.bottom, margin.top]);

                        // Update average bars
                        barSvg.selectAll("rect")
                            .data(fullDataAverages, d => d.category)
                            .join(
                                enter => enter.append("rect")
                                    .attr("x", d => x(d.category))
                                    .attr("y", d => yAverage(d.average))
                                    .attr("width", x.bandwidth())
                                    .attr("height", d => size - margin.bottom - yAverage(d.average))
                                    .attr("fill", "blue"),
                                update => update
                                    .attr("y", d => yAverage(d.average))
                                    .attr("height", d => size - margin.bottom - yAverage(d.average)),
                                exit => exit.remove()
                            );

                        // Reset y-axis
                        barSvg.select(".y-axis").call(d3.axisLeft(yAverage).tickSize(2));

                        // Reset x-axis (optional, for consistency)
                        barSvg.select(".x-axis")
                            .attr("transform", `translate(0,${size - margin.bottom})`)
                            .call(d3.axisBottom(x).tickSize(3));
                    }
                });


            }
        }

        function zoomToBrushed() {
            if (zoomedData.length === 0) return;
            if (isZoomed) {
                zoomedData = dataSubset;
                isZoomed = false;
                zoomButton.text("").style("background", "#eee");
            } else {
                isZoomed = true;
                zoomButton.text("").style("background", "#f4a261");
            }

            x.domain(d3.extent(zoomedData, d => +d[featureX])).nice();
            y.domain(d3.extent(zoomedData, d => +d[featureY])).nice();

            gX.transition().call(d3.axisBottom(x).tickSize(3));
            gY.transition().call(d3.axisLeft(y).tickSize(2));

            pointsGroup.selectAll("circle")
                .data(zoomedData, d => d[featureX] + "-" + d[featureY]) // Bind using unique key
                .join(
                    enter => enter.append("circle")
                        .attr("cx", d => x(d[featureX]))
                        .attr("cy", d => y(d[featureY]))
                        .attr("r", 3)
                        .attr("fill", pointColor)
                        .attr("opacity", 0.6),
                    update => update.transition()
                        .attr("cx", d => x(d[featureX]))
                        .attr("cy", d => y(d[featureY])),
                    exit => exit.remove() // Remove points not in zoomed selection
                );

            d3.select(container).select(".brush").call(brush.move, null);

        }

        console.log(autoGenerateModels);
        if (autoGenerateModels) {
            generateModels();
        }

    }

    function updateHighlights(classFeature = null, colorScale = null) {
        console.log("update highlights")
        // Update ALL scatter plots (change colors of they are brushed points)
        d3.selectAll(".scatter-plot .scatter-point")
            .style("fill", function () {
                
                const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-other-feature");
                const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature");
                const pointIndex = +d3.select(this).attr("data-index");
    
                const isPrediction = featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred');
                const isResidual = featureKeyX.startsWith('residual') || featureKeyY.startsWith('residual');

                if (highlightedIndices.has(pointIndex)) {
                    console.log("highlighting")
                    return brush_col; // Highlight color
                }
                /*
                return isResidual 
                    ? residual_col 
                    : (isPrediction ? predictChart_col : baseChart_col);
                
                // Determine the original color before highlighting
                const originalColor = isResidual 
                    ? residual_col 
                    : (isPrediction ? predictChart_col : (classFeature && colorScale) ? colorScale(d[classFeature]) : baseChart_col);
                */
                let originalColor = d3.select(this).attr("data-original-color");
                if (isResidual) {
                    originalColor = residual_col;
                }
                // If highlighted, change to brush color
                return highlightedIndices.has(pointIndex) ? brush_col : originalColor;

                /*if (featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred')){
                    return highlightedIndices.has(pointIndex) ? brush_col : predictChart_col;
                } else {
                    return highlightedIndices.has(pointIndex) ? brush_col : baseChart_col;
                }*/

            });

        // Update all histogram bars
        d3.selectAll(".histogram-bar")
            .style("fill", function(d) {
                const binIndices = d.indices || [];
                const featureKeyX =d3.select(this).node().closest("div").getAttribute("data-feature");
                //return binIndices.some(index => highlightedIndices.has(index)) ? brush_col : bar_col;
                const defaultColor = featureKeyX.startsWith("pred") ? predictChart_col : baseChart_col;
                const isHighlighted = binIndices.some(index => highlightedIndices.has(index));
                return isHighlighted ? brush_col : defaultColor;

            });

        // Update bar charts (frequency-based and average-based)
        d3.selectAll(".highlighted-bar").remove(); // Clear old highlights
        d3.selectAll(".bar-chart").each(function () {
            const barSvg = d3.select(this);
            const categoricalFeature = barSvg.attr("data-feature");
            const continuousFeature = barSvg.attr("data-continuous-feature");

            const isFrequencyChart = !continuousFeature; // If no continuous feature, it's a frequency chart
            const isAverageChart = !!continuousFeature; // If continuous feature exists, it's an average chart

            const filteredData = dataset.filter((_, i) => highlightedIndices.has(i));
            
            // Frequency Chart Update
            if (isFrequencyChart) {
                const brushedDataCounts = d3.rollups(
                    filteredData,
                    v => v.length,
                    d => d[categoricalFeature]
                ).map(([key, value]) => ({ category: key, count: value }));

                const margin = { top: 10, right: 10, bottom: 40, left: 40 };
                const size = 200;

                const x = d3.scaleBand()
                    .domain(barSvg.selectAll(".background-bar").data().map(d => d.category))
                    .range([margin.left, size - margin.right])
                    .padding(0.1);

                const yFrequency = d3.scaleLinear()
                    .domain([0, d3.max(barSvg.selectAll(".background-bar").data(), d => d.count)])
                    .range([size - margin.bottom, margin.top]);

                barSvg.selectAll(".highlighted-bar.frequency")
                    .data(brushedDataCounts, d => d.category)
                    .join(
                        enter => enter.append("rect")
                            .attr("class", "highlighted-bar frequency")
                            .attr("x", d => x(d.category))
                            .attr("y", d => yFrequency(d.count))
                            .attr("width", x.bandwidth())
                            .attr("height", d => size - margin.bottom - yFrequency(d.count))
                            .attr("fill", brush_col)
                            .style("opacity", 0.7),
                        update => update
                            .attr("y", d => yFrequency(d.count))
                            .attr("height", d => size - margin.bottom - yFrequency(d.count)),
                        exit => exit.remove()
                    );
            }

            // Average Chart Update
            if (isAverageChart && (filteredData.length > 0) ) {
                const brushedDataAverages = d3.rollups(
                    filteredData,
                    v => d3.mean(v, d => +d[continuousFeature]),
                    d => d[categoricalFeature]
                ).map(([key, value]) => ({ category: key, average: value || 0 }));

                const allCategories = d3.rollups(
                    dataSubset,
                    v => d3.mean(v, d => +d[continuousFeature]),
                    d => d[categoricalFeature]
                ).map(([key, value]) => ({ category: key, average: value || 0 })).map(d => d.category);

                const completeAveragesData = allCategories.map(category => {
                    const found = brushedDataAverages.find(d => d.category === category);
                    return { category, average: found ? found.average : 0 }; // Fallback to 0 for missing categories
                });

                const margin = { top: 10, right: 10, bottom: 40, left: 40 };
                const size = 200;

                const x = d3.scaleBand()
                    .domain(barSvg.selectAll(".background-bar").data().map(d => d.category))
                    .range([margin.left, size - margin.right])
                    .padding(0.1);

                const yAverage = d3.scaleLinear()
                    .domain([0, d3.max(completeAveragesData, d => d.average) || 1])
                    .range([size - margin.bottom, margin.top]);

                    barSvg.selectAll("rect")
                    .data(completeAveragesData, d => d.category)
                    .join(
                        enter => enter.append("rect")
                            .attr("x", d => x(d.category))
                            .attr("y", d => yAverage(d.average))
                            .attr("width", x.bandwidth())
                            .attr("height", d => size - margin.bottom - yAverage(d.average))
                            .attr("fill", "blue"),
                        update => update
                            .attr("y", d => yAverage(d.average))
                            .attr("height", d => size - margin.bottom - yAverage(d.average)),
                        exit => exit.remove()
                    );

                const yAxis = d3.axisLeft(yAverage).tickSize(2);
                barSvg.select(".y-axis")
                    .call(yAxis);
            }
        });

    }

    // bar chart with averages (continuous + categorical)
    function renderAverageBarChart(container, categoricalFeature, continuousFeature, cateName, contName) {
       
        visualizationMappings.push({ x: categoricalFeature, y: continuousFeature });
        
        const size = 200;
        const margin = { top: 10, right: 10, bottom: 40, left: 40 };
        const width = size - margin.left - margin.right;
        const height = size - margin.top - margin.bottom;

        d3.select(container)
            .attr("data-plot-type", "avg-bar")
            .attr("data-other-feature", categoricalFeature) 


        const isPrediction = continuousFeature.startsWith('pred'); 
        const pointColor = isPrediction ? predictChart_col : bar_col; 

// Clear previous chart inside this container
//d3.select(container).select("svg").remove();

        const data = d3.rollups(
            dataset,
            v => d3.mean(v, d => +d[continuousFeature]),
            d => d[categoricalFeature]
        ).map(([key, value]) => ({ category: key, average: value }));

        console.log("Aggregated Data:", data);

        const x = d3.scaleBand()
            .domain(data.map(d => d.category))
            .range([margin.left, width + margin.left])
            .padding(0.1);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.average)])
            .range([height + margin.top, margin.top]);

        const svg = d3.select(container).append("svg")
            .attr("width", size)
            .attr("height", size)
            .attr("class", "bar-chart")
            .attr("data-feature", categoricalFeature) // Add the categorical feature
            .attr("data-continuous-feature", continuousFeature); // Add the continuous feature

        svg.selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", d => x(d.category))
            .attr("y", d => y(d.average))
            .attr("width", x.bandwidth())
            .attr("height", d => height + margin.top - y(d.average))
            .attr("fill", pointColor);

        xAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height + margin.top})`)
            .call(d3.axisBottom(x).tickSize(3));
        
        const numCategories = data.length;

        xAxis.selectAll("text")
            .attr("text-anchor", numCategories > 4 ? "end" : "middle") // Rotate only if more than 4 categories
            .attr("dx", numCategories > 4 ? "0.7em" : "0") 
            .attr("dy", numCategories > 4 ? "0.40em" : "0.35em")
            .attr("transform", function () {
                return numCategories > 4 ? "rotate(-20)" : ""; // Rotate only when necessary
            });

        svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(y).tickSize(2));

        // Labels
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("x", width / 2 + margin.left)
            .attr("y", size - 5)
            .text(cateName);

        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("x", -height / 2)
            .attr("y", 15)
            .text(`Avg. ${contName}`);
    
        // Add remove button
        addRemoveButton(d3.select(container));
        addTestButton(d3.select(container));

        if (autoGenerateModels) {
            generateModels();
        }

    }

    // HOPs
    let currentPredictionIndex = 1; // Tracks the current prediction index (1 to 5)
    let predictionInterval = null; // Stores the interval ID
    let isCycling = false; // Track the cycling state


    document.getElementById('cycle-predictions').addEventListener('click', () => {
      
        if (isCycling) {
            // If cycling is active, deactivate it
            clearInterval(predictionInterval); // Stop the interval
            predictionInterval = null;
            isCycling = false;

        } else {
            isCycling = true;

            // Start a new interval
            predictionInterval = setInterval(() => {
                // Temporarily save highlighted points
                const savedHighlights = new Set(highlightedIndices); // Backup current highlights

                // Update all charts containing predicted values
                d3.selectAll(".plot-container").each(function () {
                    const container = this;
                    const featureKey = d3.select(container).attr("data-feature");
                    const otherFeatureKey = d3.select(container).attr("data-other-feature");
                    const plotType = d3.select(container).attr("data-plot-type");

                    // Determine the new keys for prediction and residuals based on the current index
                    const newFeatureKey = featureKey.startsWith("pred") || featureKey.startsWith("residual")
                                ? `${featureKey.split("_")[0]}_${currentPredictionIndex}`
                                : featureKey;

                    const newOtherFeatureKey = otherFeatureKey && (otherFeatureKey.startsWith("pred") || otherFeatureKey.startsWith("residual"))
                        ? `${otherFeatureKey.split("_")[0]}_${currentPredictionIndex}`
                        : otherFeatureKey;

                    // Check if the chart is based on a predicted feature
                    if (featureKey !== newFeatureKey || otherFeatureKey !== newOtherFeatureKey) {
                        const feature = features.find(f => f.key === newFeatureKey);
                        const otherFeature = features.find(f => f.key === newOtherFeatureKey);
                        

                        if (feature) {
                            d3.select(container).selectAll("*").remove(); // Clear the chart

                            if (plotType === "scatterplot") {
                                renderScatterPlot(container, newOtherFeatureKey, newFeatureKey, otherFeature.name, feature.name);
                            } else if (plotType === "distribution") {
                                renderDistributionPlot(container, newFeatureKey, feature.name);
                            } else if (plotType === "bar-chart") {
                                renderBarChart(container, newFeatureKey, feature.name);
                            }else if (plotType === "avg-bar") {
                                renderAverageBarChart(container, newOtherFeatureKey, newFeatureKey, otherFeature.name, feature.name)
                            }
                        }
                    }
                });

                // Manually trigger mouseover for the currently hovered bar
                console.log(currentHoveredBar)
                if (currentHoveredBar) {
                    console.log("dispatch")
                    d3.select(currentHoveredBar).dispatch("mouseover");
                }

                // Restore highlights after rendering the charts
                highlightedIndices = savedHighlights; // Restore saved highlights

                // Update the prediction index
                currentPredictionIndex = currentPredictionIndex % 5 + 1; // Cycle from 1 to 5

                 // Reapply highlights
                updateHighlights();

            }, 1000);
        } // Update every 1 second
    });

    function addRemoveButton(container) {
        container.append("div")
            .attr("class", "remove-button")
            .style("position", "absolute")
            .style("top", "-20px")
            .style("left", "5px")
            .style("width", "20px")
            .style("height", "20px")
            .style("background", "lightgrey")
            .style("color", "black")
            .style("text-align", "center")
            .style("border-radius", "50%")
            .style("cursor", "pointer")
            .text("X")
            .on("click", function () {
                const plotType = container.attr("data-plot-type"); // Get plot type
                container.remove(); // Remove the chart

                // If auto-generation is ON, trigger generateModels() only for specific plot types
                if (autoGenerateModels && (plotType === "scatterplot" || plotType === "avg-bar")) {
                    generateModels();
                }
            });
    }

    let hypothesis_result = null;
    const hypothesisCounters = {};


    function addTestButton(container) {
        const dataFeature = container.attr("data-feature");
        const otherFeature = container.attr("data-other-feature");

        // Add Test Button (only for prediction data)
        if (dataFeature && dataFeature.startsWith("pred")) {
            container.append("button")
                .text("Test")
                .attr("class", "test-button")
                .style("position", "absolute")
                .style("top", "-20px")
                .style("right", "40px") // Place it separately from the remove button
                .style("z-index", 10)
                .style("cursor", "pointer")
                .on("click", function () {
                    // Extract prediction index from data-feature
                    const match = dataFeature.match(/pred(\d+)_\d+/);
                    if (match) {
                        const predIndex = match[1]; // Extract the index

                        // Find the corresponding formula from hypothesis-logs
                        const modelLogs = document.getElementById('hypothesis-logs');
                        const formulaElement = modelLogs.querySelector(`[prediction-index="${predIndex}"]`);
                        if (formulaElement) {
                            const parent = formulaElement.parentElement;
                            const lines = Array.from(parent.childNodes).filter(
                                node => node.nodeType === Node.TEXT_NODE || node.tagName === "BR"
                            );
                            const meanLine = lines.find(line => 
                                line.textContent.trim().startsWith("Mean:")
                            );
                            const meanFormula = meanLine.textContent.trim().replace(/^Mean:\s*/, "");
                            
                            // Find the type of the otherFeature
                            const otherFeatureDetails = features.find(f => f.key === otherFeature);
                            const otherFeatureType = otherFeatureDetails ? otherFeatureDetails.type : "Unknown";
                            
                            console.log(meanFormula)
                            console.log(otherFeature)
                            console.log(otherFeatureType);

                            // Send data to the R API
                            fetch("http://localhost:8000/test_hypothesis", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({
                                    model: meanFormula,
                                    testVar: otherFeature,
                                    varType: otherFeatureType
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.success) {
                                    // Store the result in hypothesis_result
                                    hypothesis_result = data.results;

                                 // Create a table to display results
                                const table = document.createElement('table');
                                table.style.width = '100%';
                                table.style.borderCollapse = 'collapse';
                                table.style.marginTop = '10px';

                                // Add header row
                                const headerRow = document.createElement('tr');
                                Object.keys(hypothesis_result[0]).forEach(key => {
                                    const th = document.createElement('th');
                                    th.textContent = key;
                                    th.style.border = '1px solid #ccc';
                                    th.style.padding = '5px';
                                    th.style.backgroundColor = '#f9f9f9';
                                    th.style.textAlign = 'left';
                                    headerRow.appendChild(th);
                                });
                                table.appendChild(headerRow);

                                // Add data rows
                                hypothesis_result.forEach(row => {
                                    const dataRow = document.createElement('tr');
                                    Object.values(row).forEach(value => {
                                        const td = document.createElement('td');
                                        td.textContent = value;
                                        td.style.border = '1px solid #ccc';
                                        td.style.padding = '5px';
                                        td.style.textAlign = 'left';
                                        dataRow.appendChild(td);
                                    });
                                    table.appendChild(dataRow);
                                });

                                // Create a container for the table and the close button
                                const resultContainer = document.createElement('div');
                                resultContainer.style.marginTop = '10px';
                                resultContainer.style.position = 'relative';

                                // Add "X" button
                                const closeButton = document.createElement('div');
                                closeButton.textContent = "X";
                                closeButton.style.position = 'absolute';
                                closeButton.style.top = '0';
                                closeButton.style.right = '0';
                                closeButton.style.cursor = 'pointer';
                                closeButton.style.backgroundColor = '#f5f5f5';
                                closeButton.style.padding = '5px';
                                closeButton.style.border = '1px solid #ccc';
                                closeButton.style.borderRadius = '50%';
                                closeButton.style.width = '12px';
                                closeButton.style.height = '12px';
                                closeButton.style.display = 'flex';
                                closeButton.style.justifyContent = 'center';
                                closeButton.style.alignItems = 'center';
                                closeButton.style.fontSize = '14px';
                                closeButton.addEventListener('click', () => {
                                    modelLogs.removeChild(resultContainer);
                                });

                                resultContainer.innerHTML = `<p><strong>${getHypothesisLabel(predIndex)}</strong></p>`;

                                resultContainer.appendChild(closeButton);
                                resultContainer.appendChild(table);

                                modelLogs.appendChild(resultContainer);
                                    
                                } else {
                                    alert("Error: " + data.error);
                                }
                            })
                            .catch(error => {
                                console.error("Error:", error);
                            });
                        } else {
                            alert(`No formula found for Prediction Index: ${predIndex}`);
                        }
                    } else {
                        alert("Invalid prediction feature key format.");
                    }
                });
        }
    }

    // Function to generate hypothesis labels dynamically
    function getHypothesisLabel(predIndex) {
        if (!hypothesisCounters[predIndex]) {
            hypothesisCounters[predIndex] = 1;
        }
        const label = `Hypothesis ${hypothesisCounters[predIndex]}`;
        hypothesisCounters[predIndex]++;
        return label;
    }

    function showPredict(yVar, predictedFeatureKey, modelIndex){
        d3.selectAll(".plot-container").each(function () {
            const container = d3.select(this);
            const featureKey = container.attr("data-feature");

            if (featureKey === yVar) {
                // Get the next sibling element of the current container
                const nextSibling = container.node().nextElementSibling;

                // Check if the next sibling is already a prediction plot
                if (
                    nextSibling &&
                    d3.select(nextSibling).attr("data-feature") === predictedFeatureKey
                ) {
                    // Skip if a prediction plot already exists
                    return;
                }

                // Get the other feature used in the chart
                const otherFeatureKey = container.attr("data-other-feature");
                const plotType = container.attr("data-plot-type");
                const otherFeature = features.find(f => f.key === otherFeatureKey);
                const otherFeatureName = otherFeature ? otherFeature.name : "Unknown Feature";

                // Create a new container for the comparison chart
                const comparisonContainer = d3.select(document.createElement("div"))
                    .attr("class", "plot-container")
                    .attr("draggable", true)
                    .style("position", "relative")
                    .style("width", "200px")
                    .style("height", "200px")
                    .style("margin", "5px")
                    .attr("data-feature", predictedFeatureKey)
                    .attr("data-other-feature", otherFeatureKey)
                    .on("dragstart", function (event) {
                        event.dataTransfer.setData(
                            "draggedFeature",
                            JSON.stringify({
                                name: `Predicted (${modelIndex})`,
                                key: predictedFeatureKey,
                                type: "continuous"
                            })
                        );
                    })
                    .on("dragover", event => event.preventDefault())
                    .on("drop", function (event) {
                        event.preventDefault();
                        const draggedFeature = JSON.parse(event.dataTransfer.getData("draggedFeature"));
                        const targetFeatureKey = d3.select(this).attr("data-feature");
                        const targetFeature = features.find(f => f.key === targetFeatureKey);

                        combinePlots(draggedFeature, targetFeature, this);
                    });

                // Place the new chart next to the old chart
                container.node().insertAdjacentElement('afterend', comparisonContainer.node());

                // Render the new chart
                if (plotType === "scatterplot") {
                    renderScatterPlot(comparisonContainer.node(), otherFeatureKey, predictedFeatureKey, otherFeatureName, `Predicted (${modelIndex})`);
                } else if (plotType === "distribution") {
                    renderDistributionPlot(comparisonContainer.node(), predictedFeatureKey, `Predicted (${modelIndex})` );
                } else if (plotType === "avg-bar") {
                    renderAverageBarChart(comparisonContainer.node(), otherFeatureKey, predictedFeatureKey, otherFeatureName, `Predicted (${modelIndex})`);
                }
            }
        });
    }

    // Clear all charts functionality
    document.getElementById('clear-charts').addEventListener('click', () => {
        // Select the .drop-area container and remove all its children
        d3.select("#drop-area").selectAll(".plot-container").remove();
    });

    // Function to compute the correlation matrix
    function computeCorrelationMatrix(data, continuousFeatures) {
        const matrix = [];
        for (let i = 0; i < continuousFeatures.length; i++) {
            matrix[i] = [];
            for (let j = 0; j < continuousFeatures.length; j++) {
                const x = data.map(d => d[continuousFeatures[i]]);
                const y = data.map(d => d[continuousFeatures[j]]);
                matrix[i][j] = d3.correlation(x, y);
            }
        }
        return matrix;
    }

    // D3.js correlation helper (from d3-array)
    d3.correlation = function(x, y) {
        const meanX = d3.mean(x);
        const meanY = d3.mean(y);
        const numerator = d3.sum(x.map((xi, i) => (xi - meanX) * (y[i] - meanY)));
        const denominator = Math.sqrt(
            d3.sum(x.map(xi => Math.pow(xi - meanX, 2))) *
            d3.sum(y.map(yi => Math.pow(yi - meanY, 2)))
        );
        return numerator / denominator;
    };

    // Function to render the correlation matrix as a heatmap
    function renderCorrelationMatrix(matrix, continuousFeatures) {
        const cellSize = 15; // Smaller cell size for compact layout
        const margin = { top: 10, right: 10, bottom: 150, left: 150 };
        const legendOffset = 20; // Space between heatmap and legend
        const legendHeight = 150; // Height of the legend
        const legendWidth = 10; // Width of the legend
        const extraLegendSpace = 60;
        const width = cellSize * continuousFeatures.length + margin.left + margin.right + extraLegendSpace;
        const height = cellSize * continuousFeatures.length + margin.top + margin.bottom;

        // Create a new container for the correlation matrix
        const container = d3.select("#drop-area")
            .append("div")
            .attr("class", "plot-container correlation-matrix")
            .style("position", "relative")
            .style("width", `${width}px`)
            .style("height", `${height}px`);

        // Append an SVG for the heatmap
        const svg = container.append("svg")
            .attr("width", width)
            .attr("height", height);


        // Scales for the matrix
        const x = d3.scaleBand()
            .domain(d3.range(continuousFeatures.length))
            .range([margin.left, width - margin.right - extraLegendSpace]);
        const y = d3.scaleBand()
            .domain(d3.range(continuousFeatures.length))
            .range([margin.top, height - margin.bottom]);

        //const color = d3.scaleSequential(d3.interpolateRdBu).domain([-1, 1]);
        const neg_col = "#0000FF";
        const mid_col = "#ffffff";
        const pos_col = "#B90E0A";
        const color = d3.scaleLinear()
            .domain([-1, 0, 1]) // Negative, neutral, and positive correlations
            .range([neg_col, mid_col, pos_col]); 

        // Add a tooltip element
        const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("background", "white")
            .style("border", "1px solid black")
            .style("border-radius", "5px")
            .style("padding", "4px")
            .style("pointer-events", "none")
            .style("opacity", 0) // Start hidden
            .style("font-size", "10px"); 

        // Add cells for the heatmap
        svg.selectAll("rect")
            .data(matrix.flat().map((value, i) => {
                const rowIndex = Math.floor(i / continuousFeatures.length);
                const colIndex = i % continuousFeatures.length;
                return { value, rowIndex, colIndex }; // Include indices
            }))
            .join("rect")
            .attr("x", d => x(d.colIndex))
            .attr("y", d => y(d.rowIndex))
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("fill", d => color(d.value))
            .attr("stroke", "black") 
            .attr("stroke-width", 0.5)
            .on("mouseenter", function (event, d) {
                // Highlight the hovered square's border
                d3.select(this).attr("stroke-width", 2);
                // Highlight the row and column labels
                svg.selectAll(".x-label")
                    .style("opacity", (_, i) => (i === d.colIndex ? 1 : 0.5))
                    .style("font-weight", (_, i) => (i === d.colIndex ? "bold" : "normal"));
                svg.selectAll(".y-label")
                    .style("opacity", (_, i) => (i === d.rowIndex ? 1 : 0.5))
                    .style("font-weight", (_, i) => (i === d.rowIndex ? "bold" : "normal"));

                // Show the tooltip
                tooltip.style("opacity", 1)
                    .html(`Correlation: ${d.value.toFixed(2)}`) // Format the value to 2 decimal places
                    .style("left", `${event.pageX + 10}px`) // Position near the mouse cursor
                    .style("top", `${event.pageY + 10}px`);
                    })
            .on("mouseleave", function () {
                // Reset the square's border thickness
                d3.select(this).attr("stroke-width", 0.5);
                // Reset all labels to normal
                svg.selectAll(".x-label, .y-label")
                    .style("opacity", 1) // Restore full opacity
                    .style("font-weight", "normal"); // Reset font weight

                // Hide the tooltip
                tooltip.style("opacity", 0);
            })
            .on("click", function (event, d) {
                
                const { rowIndex, colIndex, value } = d;  // precomputed data

                // Get the corresponding variable names
                const featureX = continuousFeatures[colIndex];
                const featureY = continuousFeatures[rowIndex];
                const featureXName = features.find(f => f.key === featureX)?.name || featureX;
                const featureYName = features.find(f => f.key === featureY)?.name || featureY;

                // Render scatterplot
                const scatterplotContainer = d3.select("#drop-area")
                    .append("div")
                    .attr("class", "plot-container")
                    .style("position", "relative")
                    .style("width", "200px")
                    .style("height", "200px")
                    .style("margin", "5px")
                    .attr("data-feature", featureY)
                    .attr("data-other-feature", featureX);

                renderScatterPlot(scatterplotContainer.node(), featureX, featureY, featureXName, featureYName);
            });

        // Add feature names along the axes
        svg.selectAll(".x-label")
            .data(continuousFeatures.map(f => features.find(feat => feat.key === f)?.name || f)) // Use feature name
            .join("text")
            .attr("class", "x-label")
            .attr("x", (_, i) => x(i) + cellSize / 2)
            .attr("y", height - margin.bottom + 0)
            .attr("text-anchor", "end")
            .attr("font-size", "10px") // Smaller font size
            .attr("transform", (_, i) => `rotate(-90, ${x(i) + cellSize  }, ${height - margin.bottom + 5})`) // Rotate around the label position
            .text(d => d);

        svg.selectAll(".y-label")
            .data(continuousFeatures.map(f => features.find(feat => feat.key === f)?.name || f)) // Use feature name
            .join("text")
            .attr("class", "y-label")
            .attr("x", margin.left - 10)
            .attr("y", (_, i) => y(i) + cellSize / 2)
            .attr("text-anchor", "end")
            .attr("font-size", "10px") // Smaller font size
            .attr("dy", ".35em")
            .text(d => d);

        // Add a title to the heatmap
        /*svg.append("text")
            .attr("x", width / 2)
            .attr("y", margin.top / 2)
            .attr("text-anchor", "middle")
            .attr("font-size", "14px")
            .text("Correlation Matrix");*/
            // Add color legend

        const legendScale = d3.scaleLinear()
            .domain([-1, 1])
            .range([legendHeight, 0]);

        const legendAxis = d3.axisRight(legendScale).ticks(5);

        const legend = svg.append("g")
            .attr("transform", `translate(${width - margin.right - legendWidth - 30}, ${margin.top})`); // Position to the right of the heatmap

        // Gradient definition
        const defs = svg.append("defs");
        const gradient = defs.append("linearGradient")
            .attr("id", "legend-gradient")
            .attr("x1", "0%")
            .attr("y1", "100%")
            .attr("x2", "0%")
            .attr("y2", "0%");

        gradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", neg_col);

        gradient.append("stop")
            .attr("offset", "50%")
            .attr("stop-color", mid_col);

        gradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", pos_col);

        // Add gradient rect
        legend.append("rect")
            .attr("width", legendWidth)
            .attr("height", legendHeight)
            .style("fill", "url(#legend-gradient)");

        // Add axis for the legend
        legend.append("g")
            .attr("transform", `translate(${legendWidth}, 0)`)
            .call(legendAxis);

        // Add remove button
        addRemoveButton(container);

    }

    // Event listener for the correlation matrix button
    document.getElementById("generate-correlation-matrix").addEventListener("click", () => {
        // Check if the correlation matrix already exists
        const existingMatrix = d3.select("#drop-area .correlation-matrix");
        
        if (!existingMatrix.empty()) {
            // If the matrix exists, remove it
            existingMatrix.remove();
        } else {
            // Generate the correlation matrix if it doesn't exist
            //const continuousFeatures = features.filter(f => f.type === "continuous").map(f => f.key);
            const continuousFeatures = features
                .filter(f => f.type === "continuous" && !f.key.startsWith("pred") && !f.key.startsWith("residual")) // Exclude predicted features
                .map(f => f.key);

            if (continuousFeatures.length < 2) {
                alert("At least two continuous variables are required to generate a correlation matrix.");
                return;
            }

            const correlationMatrix = computeCorrelationMatrix(dataset, continuousFeatures);
            renderCorrelationMatrix(correlationMatrix, continuousFeatures);
        }

    });

    document.getElementById('normalize-axes').addEventListener('click', () => {
        // Find all scatterplots
        const scatterplots = d3.selectAll(".scatter-plot");

        // Collect the y-axis data for scatterplots with predictions or dependent variables
        let yValues = [];

        scatterplots.each(function () {
            const container = d3.select(this).node().parentNode;
            const featureKey = d3.select(container).attr("data-feature");

            // Check if the plot involves predictions or dependent variables
            if (featureKey.startsWith("pred") || featureKey.startsWith(features[0]["key"])) {
                dataset.forEach(d => {
                    if (d[featureKey] !== undefined) yValues.push(+d[featureKey]);
                });
            }
        });

        // Determine the global y-axis extent
        const yExtent = d3.extent(yValues);
        // Define a unified y-axis scale
        const unifiedYScale = d3.scaleLinear()
            .domain(yExtent)
            .range([200 - 40, 10]); // Adjust for plot height and margins

        // Update all relevant scatterplots to use the normalized y-axis scale
        scatterplots.each(function () {
            const container = d3.select(this).node().parentNode;
            const featureKey = d3.select(container).attr("data-feature");

            if (featureKey.startsWith("pred") || featureKey.startsWith(features[0]["key"]) ) {
                const svg = d3.select(this);

                // Update y-axis
                svg.select(".y-axis")
                    .transition()
                    .duration(500)
                    .call(d3.axisLeft(unifiedYScale).tickSize(2).ticks(10)); // Ensure identical tick positions

                // Update points' positions
                svg.selectAll(".scatter-point")
                    .transition()
                    .duration(500)
                    .attr("cy", d => unifiedYScale(d[featureKey]));
            }
        });
    });

    
    function testHypothesis(hypothesis, hypothesis_number, testType, thisModelIndex, resultCell, statusCell) {
        
        // get Mean formula for the model being tested
        const clickedCell = event.target;
        const row = clickedCell.closest('tr'); // Get the clicked row
        const modelIndex = row.cells[0].textContent.trim(); // Retrieve the Model column value (model-index)
        const modelEntry = document.querySelector(`.model-entry[model-index="${modelIndex}"]`);
        const formulaDetails = modelEntry.querySelector('.formula-details');
        //const formulaMean = formulaDetails.querySelector('p:nth-of-type(1)').textContent.replace("Mean:", "").trim();
        const formulaMeanElement = Array.from(formulaDetails.querySelectorAll('p'))
            .find(p => p.textContent.trim().startsWith("Mean:"));
        const formulaMean = formulaMeanElement.textContent.replace("Mean:", "").trim();

        // Extract the first word (with optional '*')
        const firstWordMatch = hypothesis.match(/^[\w*]+/);
        const var1 = firstWordMatch ? firstWordMatch[0] : '';

        // Extract the last word (excluding punctuation like '.')
        const lastWordMatch = hypothesis.match(/(\b\w+\b)(?=\.$)/);
        const var2 = lastWordMatch ? lastWordMatch[0] : '';

        const filters = getActiveFilters();
        
        fetch('http://localhost:8000/test_hypothesis', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: formulaMean,
                var1: var1,
                var2: var2,
                testType: testType,
                datasetName: current_dataset,
                filters: filters
            }),
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(data)
                    statusCell.textContent = 'Tested';
                    if ((testType === 'overall') || (testType === 'interaction') ) {
                        
                        let pval;
                        pval = data.results[0];

                        /*
                        if (testType === 'level_val') {
                            pval = data.results[0]["p.value"];
                        } else {
                            pval = data.results[0];
                        }
                        */

                        if (pval < 0.05 && pval > 0.01) {

                            resultCell.innerHTML = 'Significant<br>(p-val = ' + pval + ')';
                            resultCell.style.backgroundColor = '#aed580'; // Light green
                            resultCell.style.color = 'black'; 
                            resultCell.style.fontWeight = 'bold'; 

                        } else if (pval < 0.01 && pval > 0.001) {

                            resultCell.innerHTML = 'Significant<br>(p-val = ' + pval + ')';
                            resultCell.style.backgroundColor = '#a2cf6e'; // Medium green
                            resultCell.style.color = 'black'; 
                            resultCell.style.fontWeight = 'bold'; 

                        } else if (pval <= 0.001 && pval > 0.0001) {

                            resultCell.innerHTML = 'Significant<br>(p-val = ' + pval + ')';
                            resultCell.style.backgroundColor = '#97c95c'; // Dark green
                            resultCell.style.color = 'black'; 
                            resultCell.style.fontWeight = 'bold'; 

                        } else if (pval <= 0.0001) {

                            resultCell.innerHTML = 'Significant<br>(p-val < ' + 0.0001 + ')';
                            resultCell.style.backgroundColor = '#97c95c'; // Dark green
                            resultCell.style.color = 'black'; 
                            resultCell.style.fontWeight = 'bold'; 

                        } else if (pval > 0.1 ) {

                            resultCell.innerHTML = 'Not Significant<br>(p-val = ' + pval + ')';
                            resultCell.style.backgroundColor = '#d9534f'; // Dark red
                            resultCell.style.color = 'black'; 
                            resultCell.style.fontWeight = 'bold'; 

                        } else if (pval >= 0.05 && pval < 0.1) {

                            resultCell.innerHTML = 'Not Significant<br>(p-val = ' + pval + ')';
                            resultCell.style.backgroundColor = '#ffcccb'; // Light red
                            resultCell.style.color = 'black'; 
                            resultCell.style.fontWeight = 'bold'; 

                        }   
                       
                    } else if (testType == 'level_val')  {
                        
                        const cat_vals = data.results.map(item => item['contrast']);
                        const pvalues = data.results.map(item => item['p.value']);

                        resultCell.innerHTML = cat_vals.map((cat_val, index) => {
                            const pval = pvalues[index]; // Get current p-value

                            // Determine background color based on p-value conditions
                            let bgColor;
                            if (pval < 0.05 && pval > 0.01) {
                                bgColor = '#aed580'; // Light green
                            } else if (pval < 0.01 && pval > 0.001) {
                                bgColor = '#a2cf6e'; // Medium green
                            } else if (pval <= 0.001) {
                                bgColor = '#97c95c'; // Dark green
                            } else if (pval > 0.1) {
                                bgColor = '#d9534f'; // Dark red
                            } else if (pval >= 0.05 && pval < 0.1) {
                                bgColor = '#ffcccb'; // Light red
                            } else {
                                bgColor = '#ffffff'; // Default (white) if none of the conditions match
                            }

                            // If pval < 0.0001, display it as "p-val < 0.0001"
                            const pvalText = pval < 0.0001 ? "p-val < 0.0001" : `p-val = ${pval}`;

                            return `
                                <div style="background-color: ${bgColor}; 
                                            color: black; 
                                            padding: 5px; 
                                            display: flex; 
                                            align-items: center; 
                                            justify-content: center;
                                            font-weight: bold;">
                                    If ${cat_val}: ${pvalText}
                                </div>
                            `;
                        }).join('');


                        // Ensure the cell contains the colors properly
                        resultCell.style.display = "flex";
                        resultCell.style.flexDirection = "column";
                        resultCell.style.alignItems = "stretch"; // Ensures both halves fill the cell
                        resultCell.style.justifyContent = "stretch";
                        resultCell.style.height = "100%"; // Ensures it takes full height of the table row
                        resultCell.style.overflow = "hidden"; // Prevents overflow beyond cell
                        resultCell.style.padding = "0";

                    } else if (testType == 'level_slope') {
                        
                        const cat_vals = data.results.map(item => item[var2]);
                        //const slopes = data.results.map(item => item[var1+'.trend']);
                        const pvalues = data.results.map(item => item['p.value']);

                        resultCell.innerHTML = cat_vals.map((cat_val, index) => {
                            const pval = pvalues[index]; // Get current p-value

                            // Determine background color based on p-value conditions
                            let bgColor;
                            if (pval < 0.05 && pval > 0.01) {
                                bgColor = '#aed580'; // Light green
                            } else if (pval < 0.01 && pval > 0.001) {
                                bgColor = '#a2cf6e'; // Medium green
                            } else if (pval <= 0.001) {
                                bgColor = '#97c95c'; // Dark green
                            } else if (pval > 0.1) {
                                bgColor = '#d9534f'; // Dark red
                            } else if (pval >= 0.05 && pval < 0.1) {
                                bgColor = '#ffcccb'; // Light red
                            } else {
                                bgColor = '#ffffff'; // Default (white) if none of the conditions match
                            }

                            // If pval < 0.0001, display it as "p-val < 0.0001"
                            const pvalText = pval < 0.0001 ? "p-val < 0.0001" : `p-val = ${pval}`;

                            return `
                                <div style="background-color: ${bgColor}; 
                                            color: black; 
                                            padding: 5px; 
                                            display: flex; 
                                            align-items: center; 
                                            justify-content: center;
                                            font-weight: bold;">
                                    If ${cat_val}: ${pvalText}
                                </div>
                            `;
                        }).join('');


                        // Ensure the cell contains the colors properly
                        resultCell.style.display = "flex";
                        resultCell.style.flexDirection = "column";
                        resultCell.style.alignItems = "stretch"; // Ensures both halves fill the cell
                        resultCell.style.justifyContent = "stretch";
                        resultCell.style.height = "100%"; // Ensures it takes full height of the table row
                        resultCell.style.overflow = "hidden"; // Prevents overflow beyond cell
                        resultCell.style.padding = "0"; // Removes extra space that might cause overflow
                    } 

                } else {
                    alert("Error: " + data.error);
                }
            })
            .catch(error => {
                console.error("Error:", error);
                alert("An error occurred while testing the hypothesis.");
            });
    }

    let hypothesesObject

    
    function createHypoObj() {
        hypothesesObject = {};

        const formulaMean = document.getElementById('formulaMean').value;
        const [dependentVariable, predictors] = formulaMean.split('~').map(s => s.trim());

        // Split terms and identify interaction terms
        const expandedTerms = predictors
            .split('+')
            .map(term => term.trim())
            .filter(Boolean); // Remove empty strings

        const interactionTerms = expandedTerms.filter(term => term.includes('*'));
        const independentVariables = expandedTerms
            .flatMap(term => (term.includes('*') ? term.split('*').map(s => s.trim()) : term.trim()))
            .filter(Boolean);

        // Deduplicate independent variables
        const uniqueIndependentVariables = [...new Set(independentVariables)];

        // Identify categorical variables
        const categoricalVariables = uniqueIndependentVariables.filter(p => {
            const feature = features.find(f => f.key === p);
            return feature && feature.type === 'categorical';
        });

        // Identify variables interacting with categorical variables
        const interactingWithCategorical = [];
        interactionTerms.forEach(term => {
            const components = term.split('*').map(s => s.trim());
            const categorical = components.find(comp => categoricalVariables.includes(comp));
            if (categorical) {
                components.forEach(comp => {
                    if (comp !== categorical) {
                        interactingWithCategorical.push({ variable: comp, categorical });
                    }
                });
            }
        });

        const uniqueInteractingWithCategorical = [...new Set(interactingWithCategorical.map(JSON.stringify))].map(JSON.parse);

        let hypothesisCounter = 1;
        let hypothesisSet = new Set(); // Set to store unique hypothesis strings

        function addHypothesis(hypothesis, type, testType) {
            if (!hypothesisSet.has(hypothesis)) { // Ensure uniqueness
                hypothesesObject[`H${hypothesisCounter}`] = {
                    id: `H${hypothesisCounter}`,
                    hypothesis: hypothesis,
                    type: type,
                    testType: testType
                };
                hypothesisSet.add(hypothesis); // Store in set to track duplicates
                hypothesisCounter++;
            }
        }

        // Add independent variable hypotheses
        independentVariables.forEach(variable => {
            addHypothesis(
                `${variable} and its interaction (if any) significantly improve model fit to predict ${dependentVariable}.`,
                "Main and Interaction",
                "overall"
            );
        });

        // Add interaction term hypotheses
        interactionTerms.forEach(term => {
            addHypothesis(
                `${term} significantly improves model fit to predict ${dependentVariable}.`,
                "Interaction Only",
                "interaction"
            );
        });

        // Add categorical variable level effects
        categoricalVariables.forEach(categorical => {
            addHypothesis(
                `${dependentVariable} is significantly different at each level of ${categorical}.`,
                "Categorical Level",
                "level_val"
            );
        });

        // Add interactions with categorical variables
        uniqueInteractingWithCategorical.forEach(({ variable, categorical }) => {
            addHypothesis(
                `${variable} has a significant effect on ${dependentVariable} within each level of ${categorical}.`,
                "Categorical Level",
                "level_slope"
            );
        });

        console.log('Generated Hypotheses Object:', hypothesesObject);
    }


    function correctMultiple(pval, testType, adjustCell) {
        const totalHypotheses = document.querySelectorAll('#hypothesisTable tr').length - 1;

        if ((testType == 'overall') || (testType == 'interaction')) {

            if (pval < 0.05/totalHypotheses && pval > 0.01/totalHypotheses) {

                adjustCell.innerHTML = 'Significant<br>(p-val = ' + pval + ')';
                adjustCell.style.backgroundColor = '#aed580'; // Light green
                adjustCell.style.color = 'black'; 
                adjustCell.style.fontWeight = 'bold'; 

            } else if (pval < 0.01/totalHypotheses && pval > 0.001/totalHypotheses) {

                adjustCell.innerHTML = 'Significant<br>(p-val = ' + pval + ')';
                adjustCell.style.backgroundColor = '#a2cf6e'; // Medium green
                adjustCell.style.color = 'black'; 
                adjustCell.style.fontWeight = 'bold'; 

            } else if (pval < 0.001/totalHypotheses) {

                adjustCell.innerHTML = 'Significant<br>(p-val = ' + pval + ')';
                adjustCell.style.backgroundColor = '#97c95c'; // Dark green
                adjustCell.style.color = 'black'; 
                adjustCell.style.fontWeight = 'bold'; 

            } else if (pval > 0.1/totalHypotheses ) {

                adjustCell.innerHTML = 'Not Significant<br>(p-val = ' + pval + ')';
                adjustCell.style.backgroundColor = '#d9534f'; // Dark red
                adjustCell.style.color = 'black'; 
                adjustCell.style.fontWeight = 'bold'; 

            } else if (pval > 0.05/totalHypotheses && pval < 0.1/totalHypotheses) {

                adjustCell.innerHTML = 'Not Significant<br>(p-val = ' + pval + ')';
                adjustCell.style.backgroundColor = '#ffcccb'; // Light red
                adjustCell.style.color = 'black'; 
                adjustCell.style.fontWeight = 'bold'; 

            }   
            
        } else if (testType == 'level_slope') {
            
            
        } else if (testType == 'level_val') {

        }

    }

    function createHypoVis(hypothesis, testType) {
        console.log(testType)

        // Extract the first word (with optional '*')
        const firstWordMatch = hypothesis.match(/^[\w*]+/);
        const var1 = firstWordMatch ? firstWordMatch[0] : '';

        // Extract the last word (excluding punctuation like '.')
        const lastWordMatch = hypothesis.match(/(\b\w+\b)(?=\.$)/);
        const var2 = lastWordMatch ? lastWordMatch[0] : '';

        if (testType == 'interaction') {

            let interaction = var1;
            let [interact1, interact2] = interaction.split("*");

            console.log(interact1);
            console.log(interact2);
            console.log(var2);

            const feature_interact_1 = features.find(f => f.key === interact1);
            const feature_interact_2 = features.find(f => f.key === interact2);
            const feature2 = features.find(f => f.key === var2);

            const plotContainer1 = dropArea.append("div")
                .attr("class", "plot-container")
                .attr("draggable", true)
                .style("position", "relative")
                .style("width", "200px")
                .style("height", "200px")
                .style("margin", "5px")
                .attr("data-feature", interact1)

            renderScatterPlot(plotContainer1.node(), interact1, var2, feature_interact_1.name, feature2.name);

            const plotContainer2 = dropArea.append("div")
                .attr("class", "plot-container")
                .attr("draggable", true)
                .style("position", "relative")
                .style("width", "200px")
                .style("height", "200px")
                .style("margin", "5px")
                .attr("data-feature", interact2)
                
            renderBarChart(plotContainer2.node(), feature_interact_2.key, feature_interact_2.name);

        } else if (testType == 'level_slope') {
            const classFeature = var2;
            const feature1 = features.find(f => f.key === var1);
            const feature_dependent = features[0];
            
            console.log(var1);
            console.log(var2);

            const plotContainer1 = dropArea.append("div")
                .attr("class", "plot-container")
                .attr("draggable", true)
                .style("position", "relative")
                .style("width", "200px")
                .style("height", "200px")
                .style("margin", "20px")
                .attr("data-feature", feature_dependent["key"])
                .node()

            d3.select(plotContainer1).append("div")
                .attr("class", "dataset-status")
                .style("text-align", "center")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .style("margin-bottom", "5px")
                .text(document.getElementById("filter-message").textContent); 

            

            console.log(features)
            console.log(feature_dependent)
            
            // Get unique class values
            const classValues = [...new Set(dataset.map(d => d[classFeature]))];
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(classValues);

            //console.log("Unique Class Values:", classValues);
            //console.log("Color Scale Mapping:", classValues.map(c => [c, colorScale(c)]));

            // scatterplot for full data
            renderScatterPlot(plotContainer1, var1, feature_dependent.key, feature1.name, feature_dependent.name, dataset, classFeature, colorScale);

            // Create scatter plots for each class subset dynamically
            classValues.forEach(classValue => {

                const plotContainer = dropArea.append("div")
                    .attr("class", "plot-container")
                    .attr("draggable", true)
                    .style("position", "relative")
                    .style("width", "200px")
                    .style("height", "200px")
                    .style("margin", "20px")
                    .attr("data-feature", feature_dependent["key"])
                    .node()

                d3.select(plotContainer).append("div")
                    .attr("class", "dataset-status")
                    .style("text-align", "center")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("margin-bottom", "5px")
                    .text(classValue); 

                const subset = dataset.filter(d => d[classFeature] === classValue);
              
                renderScatterPlot(plotContainer, var1, feature_dependent.key, feature1.name, feature_dependent.name, subset, classFeature, colorScale);

            });


        } else {
            const feature1 = features.find(f => f.key === var1);
            const feature2 = features.find(f => f.key === var2);


            const plotContainer = dropArea.append("div")
                .attr("class", "plot-container")
                .attr("draggable", true)
                .style("position", "relative")
                .style("width", "200px")
                .style("height", "200px")
                .style("margin", "5px")
                .attr("data-feature", var1)

            if ( (feature1.type == 'continuous') && (feature2.type == 'continuous') ) {

                renderScatterPlot(plotContainer.node(), var1, var2, feature1.name, feature2.name);

            } else if ( (feature1.type == 'continuous') && (feature2.type == 'categorical') ){

                renderAverageBarChart(plotContainer.node(), var2, var1, feature2.name, feature1.name);

            } else if ( (feature1.type == 'categorical') && (feature2.type == 'continuous') ) {

                renderAverageBarChart(plotContainer.node(), var1, var2, feature1.name, feature2.name);
                
            }
        }

        
    }

    function addSmallVis(cell, testType, hypothesis) {

        const width = 50; 
        const height = 50; 

        if ( (testType == 'interaction') || (testType == 'level_slope') ) {
            const radius = 2.5; // Increased radius
            const margin = radius + 1; // Ensure space for larger circles
            const fixedNoise = [-4, 3, -2, 4, -5, 5, -3, 3, -4, 2, -2, 3, -3, 4, -2, 
                            3, -1, 2, -3, 3, -2, 4, -4, 4, -1, 3, -2, 3, -3, 4];
            // Define two groups for interaction effect
            const data = Array.from({ length: 30 }, (_, i) => {
                const x = i + 1;
                const baseY = (x % 5) * 2 + 10; // Base trend
                const group = i < 20 ? "A" : "B"; // First 20 points = A, last 10 = B
                return { x, y: Math.max(0, baseY + fixedNoise[i]), group };
            });

            const svg = d3.select(cell)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(data, d => d.x))
                .range([margin, width - margin]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.y) + margin])
                .range([height - margin, margin]);

            // Add scatter points with two colors for interaction groups
            svg.selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", radius)
                .attr("fill", d => d.group === "A" ? "steelblue" : "orange");

        } else {

            // Extract the first word (with optional '*')
            const firstWordMatch = hypothesis.match(/^[\w*]+/);
            const var1 = firstWordMatch ? firstWordMatch[0] : '';

            // Extract the last word (excluding punctuation like '.')
            const lastWordMatch = hypothesis.match(/(\b\w+\b)(?=\.$)/);
            const var2 = lastWordMatch ? lastWordMatch[0] : '';

            const feature1 = features.find(f => f.key === var1);
            const feature2 = features.find(f => f.key === var2);
        
            if ( (feature1.type === 'continuous') && (feature2.type === 'continuous') ) {
                const radius = 2.5; // Increased radius
                const margin = radius + 1; // Ensure space for larger circles
                const fixedNoise = [-5, 8, -3, 6, -7, 9, -4, 7, -8, 5, -6, 10, -3, 7, -9];

                const data = Array.from({ length: 15 }, (_, i) => {
                    const x = i + 1;
                    const baseY = x * 1.6; // Base increasing trend
                    return { x, y: Math.max(0, baseY + fixedNoise[i]) }; // Apply fixed noise
                });

                const svg = d3.select(cell)
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                const xScale = d3.scaleLinear()
                    .domain(d3.extent(data, d => d.x))
                    .range([margin, width - margin]);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.y) + margin]) // Adjust y-scale dynamically
                    .range([height - margin, margin]); // Invert y-axis

                // Add scatter points
                svg.selectAll("circle")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", radius)
                    .attr("fill", "steelblue");

            } else if ( (feature1.type === 'categorical') || (feature2.type === 'categorical') ) {
                const margin = { top: 5, right: 5, bottom: 5, left: 5 };

                const data = [
                    { name: "Bar 1", value: 10 }, 
                    { name: "Bar 2", value: 20 }  
                ];

                const svg = d3.select(cell)
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                // Scales
                const xScale = d3.scaleBand()
                    .domain(data.map(d => d.name)) // Bar labels
                    .range([margin.left, width - margin.right])
                    .padding(0.2);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.value)]) // Scale up to the max value
                    .range([height - margin.bottom, margin.top]);

                // Draw the bars
                svg.selectAll("rect")
                    .data(data)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.name))
                    .attr("y", d => yScale(d.value))
                    .attr("width", xScale.bandwidth())
                    .attr("height", d => height - margin.bottom - yScale(d.value))
                    .attr("fill", "steelblue");

            } 
        }
    }

    function sortTableByCustomOrder(tableId, primaryIndex, secondaryIndex, customOrder = [], ascending = true) {
        const table = document.getElementById(tableId); // Get the table
        const rows = Array.from(table.querySelectorAll("tr")).slice(1); // Exclude the header row

        // Sort rows
        rows.sort((rowA, rowB) => {
            const primaryValueA = rowA.cells[primaryIndex].textContent.trim();
            const primaryValueB = rowB.cells[primaryIndex].textContent.trim();

            if (customOrder.length > 0) {
                // Custom order sorting
                const rankA = customOrder.indexOf(primaryValueA);
                const rankB = customOrder.indexOf(primaryValueB);

                if (rankA < rankB) return ascending ? -1 : 1;
                if (rankA > rankB) return ascending ? 1 : -1;
            } else {
                // Default sorting (natural order)
                if (primaryValueA < primaryValueB) return ascending ? -1 : 1;
                if (primaryValueA > primaryValueB) return ascending ? 1 : -1;
            }

            // If primary values are equal, compare secondary column values
            const secondaryValueA = rowA.cells[secondaryIndex].textContent.trim();
            const secondaryValueB = rowB.cells[secondaryIndex].textContent.trim();

            // Handle secondary sorting as text (or numeric if needed)
            if (secondaryValueA < secondaryValueB) return ascending ? -1 : 1;
            if (secondaryValueA > secondaryValueB) return ascending ? 1 : -1;

            return 0; // Both primary and secondary are equal
        });

        // Reinsert sorted rows into the table
        rows.forEach(row => table.appendChild(row));
    }


    function updateStatusColumn() {
        const table = document.getElementById("hypothesisTable"); // Get the table
        const rows = Array.from(table.querySelectorAll("tr")).slice(1); // Exclude the header row

        rows.forEach(row => {
            const statusCell = row.cells[5]; // Get the Status cell (column index = 6)
            if (statusCell.textContent.trim().toLowerCase() === "new") {
                statusCell.textContent = "Untested"; // Replace "Recent" with "Untested"
            }
        });
    }

    function updateHypothesisCount() {
        const totalHypotheses = document.querySelectorAll('#hypothesisTable tr').length - 1; // Exclude header row
        document.getElementById('total-hypotheses').textContent = totalHypotheses;
    }

    function addTableEventListeners() {
        const tableHeaders = document.querySelectorAll('#hypothesisTable th');

        tableHeaders.forEach((header, index) => {
            if (index === 0 || index === 1) {  // 0 = Model, 1 = Hypothesis, 2 = Effect Type
                header.addEventListener('click', () => {
                    console.log("header");
                    sortTableByCustomOrder("hypothesisTable", index, 5, customOrder = [], true);
                });
            }
        });
    }

    // Track all created charts
    let visualizationMappings = [];

    // Generate the mean formula when the button is clicked
    document.getElementById("generate-models").addEventListener("click", function () {
        let groupedByY = {};  // Store features grouped by the same y-axis
        let interactionTerms = new Set(); // Track interaction terms

        // Filter out removed charts
        let validCharts = document.querySelectorAll(".plot-container");
        let validChartKeys = new Set();
        validCharts.forEach(chart => {
            let featureX = chart.getAttribute("data-other-feature");
            let featureY = chart.getAttribute("data-feature");
            if (featureX && featureY) {
                validChartKeys.add(`${featureX}-${featureY}`);
            }
        });

        // Remove any charts from `visualizationMappings` that no longer exist
        visualizationMappings = visualizationMappings.filter(chart => 
            validChartKeys.has(`${chart.x}-${chart.y}`)
        );

        // Group x-variables by their respective y-variables
        visualizationMappings.forEach(chart => {
            if (!groupedByY[chart.y]) {
                groupedByY[chart.y] = new Set();
            }
            groupedByY[chart.y].add(chart.x);
        });

        // Check for interactions: If an x-variable appears as a y-variable, introduce an interaction term
        visualizationMappings.forEach(chart => {
            if (groupedByY[chart.x]) {  // If the x-variable has been used as a y-variable
                groupedByY[chart.x].forEach(otherX => {
                    interactionTerms.add(`${chart.x}*${otherX}`); // Create interaction effect
                });
            }
        });

        // Construct the mean formula
        let formulas = Object.entries(groupedByY).map(([y, xSet]) => {
            let xFeatures = Array.from(xSet);
            
            // Remove main effects if interaction exists
            let finalFeatures = new Set(xFeatures);
            let usedVariables = new Set();

            console.log(interactionTerms)
            interactionTerms.forEach(interaction => {
                let [var1, var2] = interaction.split(" * ");
                
                if (xFeatures.includes(var1) || xFeatures.includes(var2)) {
                    console.log(interaction);
                    finalFeatures.delete(var1);
                finalFeatures.delete(var2);
                finalFeatures.add(interaction); // Add only interaction term
                usedVariables.add(var1);
                usedVariables.add(var2);
                }
            });

            // Add remaining non-interacting variables
            xFeatures.forEach(x => {
                if (!usedVariables.has(x)) {
                    finalFeatures.add(x);
                }
            });
            

            // Ensure `y` is removed as a predictor
            finalFeatures.forEach(term => {
                if (term.includes(y)) {
                    finalFeatures.delete(term);
                    // If it's an interaction term, remove just `y` from it
                    let remainingTerms = term.split(" * ").filter(t => t !== y);
                    if (remainingTerms.length === 1) {
                        finalFeatures.add(remainingTerms[0]); // Keep only the other variable
                    }
                }
            });

            console.log(finalFeatures)
            //return `${y} ~ ${Array.from(finalFeatures).join(" + ")}`;
            return finalFeatures.size > 0 ? `${y} ~ ${Array.from(finalFeatures).join(" + ")}` : `${y} ~ 1`;

        });

        console.log(visualizationMappings);

        // Append formulas inside .column-3 area
        const outputDiv = document.getElementById("generated-models-output");

        formulas.forEach(formula => {
            const formulaEntry = document.createElement("p");
            formulaEntry.textContent = formula;

            // Create dashed line
            const dashedLine = document.createElement("hr");
            dashedLine.style.border = "0";
            dashedLine.style.borderTop = "1px dashed #000"; // Dashed line style
            dashedLine.style.margin = "5px 0"; // Spacing

            // Append to output div
            outputDiv.appendChild(formulaEntry);
            outputDiv.appendChild(dashedLine);
        });
    });

    document.getElementById("autoGenerateToggle").addEventListener("change", function () {
        autoGenerateModels = this.checked;
    });


    function generateModels() {
        document.getElementById("generate-models").click();
    }



  </script>
</body>
</html>
