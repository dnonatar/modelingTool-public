<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual-Language Modeling</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .header-button {
            padding: 3px 5px;
            color: black;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
        }

        /* Hover effect only for header buttons */
        .header-button:hover {
            background: lightgrey;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: row; 
            align-items: flex-start;
            height: 100vh;
            padding: 20px;
            background-color: #f4f4f4;
        }

        #buttonContainer {
            display: flex;
            gap: 10px; /* Space between buttons */
            position: absolute;
            top: 20px;
            left: 20px;
        }

        /* Left Panel */
        #leftPanel {
            width: 250px;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            display: none; /* Hidden initially */
            position: absolute;
            top: 50px;
            left: 20px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease-in-out;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            border: 1px solid #ccc;
            padding: 5px;
            text-align: left;
        }

        th {
            background: lightgrey;
            color: black;
        }

        /* Chatbox */
        #chatContainer {
            margin-left: 10px; 
            margin-top: 10px;
            width: 400px;
        }

        #chatbox {
            
            height: 400px;
            border: 1px solid #ccc;
            border-radius: 10px;
            background: white;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
        }

        .message {
            max-width: 80%;
            padding: 10px;
            margin: 5px;
            border-radius: 10px;
            display: inline-block;
        }

        .user {
            align-self: flex-end;
            background: blue;
            color: white;
            border: 1px solid #ccc;
        }

        .bot {
            align-self: flex-start;
            background: whitesmoke;
            color: black;
            border: 1px solid #ccc;
        }

        #inputContainer {
            display: flex;
            gap: 5px;
        }

        #userInput {
            width: 400px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        button:hover {
            background: #0056b3;
        }

        #mainContent {
            display: flex;
            flex-direction: column; /* Stack feature-list above resultsContainer */
            width: 100%;
        }

        /* Right Panel */
        #resultsContainer {
            flex-grow: 1; /* Takes all available space */
            margin-left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .result-panel {
            border: 0.5px solid black;
            border-radius: 3px;
            margin-bottom: 10px;
            background-color: #e5e5e5;
            overflow: hidden;
        }

        .result-header {
            background-color:#e5e5e5;
            color: black;
            padding: 5px;
            cursor: pointer;
            border-radius: 3px;
        }

        .result-content {
            padding: 10px;
            display: none; /* Hidden by default */
            background: #f8f9fa;
        }

        #feature-list {
            width: 100%;
            padding: 2px;
            background: #f8f9fa;
            border: 1px solid #ccc;
            margin-bottom: 10px; /* Space between feature list and results */
            margin-left: 20px;
            display: flex;  /* Ensures items are in a row */
            flex-wrap: wrap; /* Wraps to a new line if there's not enough space */
            gap: 5px; /* Adds spacing between feature items */

        }

        .feature-item {
            padding: 5px 8px; /* Reduce padding for smaller size */
            font-size: 12px; /* Reduce font size for compact appearance */
            margin: 2px; /* Add small margins for spacing */
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: grab;
            white-space: nowrap;
            border-radius: 4px; /* Optional: add rounded corners */
        }

        .hypothesis-summary-table {
            font-size: 12px !important;
        }

    </style>
</head>
<body>

    <div id="buttonContainer">
        <button id="toggleInfoBtn" class="header-button" onclick="toggleDataInfo()">Data</button>
        <button id="toggleFeatureBtn" class="header-button" onclick="toggleFeatureList()">Feature List</button>
        <button id="toggleHOPsBtn" class="header-button" style="display: none;">Activate HOPs</button>
    </div>

    <!-- Left Panel (Initially Hidden) -->
    <div id="leftPanel">
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody id="featureTableBody"></tbody>
        </table>
    </div>

    <!-- Chat Container -->
    <div id="chatContainer">
        <h2></h2>
        <div id="chatbox"></div>
        <div id="inputContainer">
            <input type="text" id="userInput" placeholder="Enter your message here">
            <button onclick="sendMessage()">Send</button>
        </div>
    </div>

    <div id="mainContent">
            <div id="feature-list" style="display: none;"></div>
            <div id="resultsContainer"></div>
    </div>

    <script>

        const API_KEY = '......';   //replace with api key
        const gpt_model = "gpt-4";

        // colors
        const baseChart_col = "#69b3a2";
        const predictChart_col = "#0096FF";
        const bar_col = "#ccc";
        const brush_col = "orange";

        let highlightedIndices = new Set();
        let currentHoveredBar = null; // Track the currently hovered bar

        let dataSubset;

        let predCounter = 1;

        // HOPs
        let isCycling = false;
        let predictionInterval = null;
        let currentPredictionIndex = 1;

        // tracking whether user wants to test hypothesis
        let awaitingStatTestResponse = false;
        let lastFormula = null;

        let hypothesesObject;

        const customCategoryOrder = {
            class: ["Economy", "Business"],
            stops: ["zero", "one", "two_or_more"],
            arrival: ["Early_Morning", "Morning", "Afternoon", "Evening", "Night", "Late_Night"],
            departure: ["Early_Morning", "Morning", "Afternoon", "Evening", "Night", "Late_Night"]
            
        };

        const queryLabelMap = {};
        let queryCounter = 1;

        let droppedFeature = null;

        const testResultsByModel = new Map();

        // Load the new dataset
        datasetPath = "data/cleaned_airline.csv";
        d3.csv(datasetPath).then(data => {
            dataset = data;
            full_dataset = data;
            dataset.forEach(d => {
                Object.keys(d).forEach(key => {
                    d[key] = isNaN(+d[key]) ? d[key] : +d[key]; // Convert numeric values
                });
            });

            dataSubset = dataset;

            showInitialBotMessage();

        });


        // Feature data
        const features = [
            { name: "Price", key: "price", type: "continuous" },
            { name: "Days remaining", key: "days_remain", type: "continuous" },
            { name: "Flight duration", key: "duration", type: "continuous" },
            { name: "Class", key: "class", type: "categorical" },
            { name: "Destination", key: "destination", type: "categorical" },
            { name: "Arrival", key: "arrival", type: "categorical" },
            { name: "Stops", key: "stops", type: "categorical" },
            { name: "Departure", key: "departure", type: "categorical" },
            { name: "Origin", key: "origin", type: "categorical" },
            { name: "Airline", key: "airline", type: "categorical" }
        ];

        // Populate Table
        function populateFeatureTable() {
            const tableBody = document.getElementById("featureTableBody");
            tableBody.innerHTML = ""; // Clear existing content

            features.forEach(feature => {
                const row = `<tr><td>${feature.name}</td><td>${feature.type}</td></tr>`;
                tableBody.innerHTML += row;
            });
        }

        function updateFeatureList(features) {
            const featureList = d3.select("#feature-list");
            featureList.selectAll("*").remove(); // Clear previous features

            featureList.selectAll(".feature-item")
                .data(features)
                .enter()
                .append("div")
                .attr("class", d => d.type === "categorical" ? "feature-item categorical-feature" : "feature-item")
                .attr("draggable", true)
                .text(d => d.name)
                .on("dragstart", function (event, d) {
                    event.dataTransfer.setData("feature", JSON.stringify(d));
                })
                .each(function (d) {
                    if (d.type === "categorical") {
                        createCategoryDropdown(d3.select(this), d);
                    }
                });
        }

        updateFeatureList(features)

        // Toggle Left Panel Visibility
        function toggleDataInfo() {
            const panel = document.getElementById("leftPanel");
            const button = document.getElementById("toggleInfoBtn");

            if (panel.style.display === "none" || panel.style.display === "") {
                panel.style.display = "block";
                button.textContent = "Hide";
                populateFeatureTable();
            } else {
                panel.style.display = "none";
                button.textContent = "Data";
            }
        }

        async function sendMessage() {
            const userInput = document.getElementById("userInput").value;
            if (!userInput) return;

            const chatbox = document.getElementById("chatbox");

            // Add user message to chatbox
            const userMessage = document.createElement("div");
            userMessage.classList.add("message", "user");
            userMessage.textContent = userInput;
            chatbox.appendChild(userMessage);
            chatbox.scrollTop = chatbox.scrollHeight;

            document.getElementById("userInput").value = ""; // Clear input

            /*
            // Do i need awaitingStatTestResponse?
            if (awaitingStatTestResponse) {
                
                awaitingStatTestResponse = false;

                const lowerInput = userInput.toLowerCase();
                if (lowerInput.includes("statistical test") || lowerInput.includes("hypothesis test")) {

                    // get the model of interest (current or previous)
                    const model_number = predCounter - 1;  // if current model

                    // create a list of all possible hypotheses based on this model
                    createHypoObj(model_number);

                    matchHypo(userInput);
                    
                    return; // Skip normal GPT call
                }

            }
            */

            const lowerInput = userInput.toLowerCase();
            if (lowerInput.includes("statistical test") || lowerInput.includes("hypothesis test")) {

                // get the model of interest (current or previous)
                const model_number = predCounter - 1;  // if current model

                // create a list of all possible hypotheses based on this model
                createHypoObj(model_number);

                matchHypo(userInput);
                
                return; // Skip normal GPT call
            }

            if (lowerInput.includes("recommendation") || lowerInput.includes("suggestion")) {
                const chatbox = document.getElementById("chatbox");
                const botMessage = document.createElement("div");
                botMessage.classList.add("message", "bot");
                botMessage.textContent = "Have you accounted for effects by a specific category?";
                chatbox.appendChild(botMessage);
                chatbox.scrollTop = chatbox.scrollHeight;
            }



            // Features available in the dataset
            const availableKeys = features.map(f => f.key).join(", ");
            const availableNames = features.map(f => f.name).join(", ");

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${API_KEY}`
                },
                body: JSON.stringify({
                    model: gpt_model,
                    messages: [
                        { role: "system", content: "You are an AI assistant that helps users build R formulas for linear regression models." },
                        { role: "user", content: 
                            `Check if all variables in this request exist in the dataset: "${userInput}". 
                            The available variables are: ${availableKeys}. 
                            If any variable is missing, list them explicitly and do NOT generate an R formula.
                            If all variables exist, generate an R formula in the format: response_variable ~ predictor1 + predictor2.
                            Predictors such as predictor1 should be the corresponding key from ${availableKeys} that is similar to the input.
                            Answer with one sentence, either just the formula or the listed variables that cannot be found.
                            If there is formula, start sentence with "Here is the linear model corresponding to your interpretation: " 
                            If there is no formula, reply with "Please try a different query."
                            `     
                        }
                    ],
                    max_tokens: 100
                })
            });

            const data = await response.json();
            const botResponse = data.choices[0].message.content.trim();

            // Add bot message bubble
            const botMessage = document.createElement("div");
            botMessage.classList.add("message", "bot");
            botMessage.textContent = botResponse;
            chatbox.appendChild(botMessage);
            chatbox.scrollTop = chatbox.scrollHeight;

            if (botResponse.startsWith("Here is the linear model corresponding to your interpretation")) {
                // Follow-up system message
                setTimeout(() => {
                    const followUp = document.createElement("div");
                    followUp.classList.add("message", "bot");
                    followUp.textContent = "Are you interested in performing a statistical test? Or would you like to add/explore other variables?";
                    chatbox.appendChild(followUp);
                    chatbox.scrollTop = chatbox.scrollHeight;

                    awaitingStatTestResponse = true;

                }, 1500); 
            }

            // Extract R formula from bot response (Regex Approach)
            const formulaMatch = botResponse.match(/([a-zA-Z_]+\s*~\s*[a-zA-Z_0-9:+()^*\/\s-]+)/);
            if (formulaMatch) {
                lastFormula = formulaMatch[0].trim();
            }

            if (formulaMatch) {
                console.log(lastFormula)

                try {
                    const response = await fetch("http://localhost:8000/fit_model", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ 
                                formula_mean: lastFormula,
                                formula_std_dev: "~1",
                                distribution: "NO()",
                                datasetName: "airline",
                                filters: ""
                            }) 
                    });

                    const data = await response.json();
                    console.log(data)
                    const aic = data.aic;
                    const rsq = data.rsq;

                    addResultPanel(lastFormula, aic, rsq, dataset, data.result);

                } catch(error) {
                    console.log(error.message)
                }
            }
        }

        async function suggestModel(userInput) {
            const featureDescriptions = features.map(f => `${f.key} (${f.name.toLowerCase()})`).join(", ");

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${API_KEY}`
                },
                body: JSON.stringify({
                    model: gpt_model,
                    messages: [
                        {
                            role: "system",
                            content: `You are a helpful assistant. Your task is to identify dataset feature keys mentioned (even loosely) in a user message. The dataset contains the following keys and their human-friendly names: ${featureDescriptions}.`
                        },
                        {
                            role: "user",
                            content: `From this user input, identify which dataset features are being referred to. Match exact terms, synonyms, or variations (e.g., "stop" → "stops", "ticket price" → "price", etc.).

        User input: "${userInput}"

        Return a JSON array of the feature *keys* that apply. No explanation. Only the JSON list.`
                        }
                    ],
                    temperature: 0.3,
                    max_tokens: 100
                })
            });

            const data = await response.json();
            const reply = data.choices[0].message.content.trim();

            try {
                const matchedKeys = JSON.parse(reply);
                console.log("Matched keys:", matchedKeys);
                return matchedKeys;
            } catch (err) {
                console.warn("Could not parse JSON response:", reply);
                return [];
            }
        }

/*
        function generateUpdatedFormula(matchedKeys) {
            // Find the last model's formula
            const lastPanel = document.querySelector(`.result-panel[panel_number="${predCounter - 1}"]`);
            if (!lastPanel) return null;

            const headerText = lastPanel.querySelector(".result-header")?.textContent;
            if (!headerText) return null;

            const match = headerText.match(/Model \d+: (.+)/);
            if (!match) return null;

            const currentFormula = match[1];
            const [outcome, predictors] = currentFormula.split("~").map(s => s.trim());

            const existingPredictors = predictors.split("+").map(p => p.trim());
            const newPredictors = [...new Set([...existingPredictors, ...matchedKeys])];

            const updatedFormula = `${outcome} ~ ${newPredictors.join(" + ")}`;

            return updatedFormula;
        }
        */

        function generateUpdatedFormula(matchedKeys) {
    const lastPanel = document.querySelector(`.result-panel[panel_number="${predCounter - 1}"]`);
    if (!lastPanel) return null;

    const headerText = lastPanel.querySelector(".result-header")?.textContent;
    if (!headerText) return null;

    const match = headerText.match(/Model \d+: (.+)/);
    if (!match) return null;

    const currentFormula = match[1];
    const [outcome, predictors] = currentFormula.split("~").map(s => s.trim());
    const existingPredictors = predictors.split("+").map(p => p.trim());

    // Remove outcome variable from matchedKeys
    const cleanedKeys = matchedKeys.filter(k => k !== outcome);

    // Get new predictors only
    const allPredictors = new Set(existingPredictors);
    const newKeys = cleanedKeys.filter(k => !allPredictors.has(k));

    const finalTerms = [...existingPredictors, ...newKeys];

    // Add interactions between existing and new
    for (const key1 of existingPredictors) {
        for (const key2 of newKeys) {
            if (key1 !== key2) {
                finalTerms.push(`${key1}:${key2}`);
            }
        }
    }


    const uniqueTerms = [...new Set(finalTerms)]; // Avoid duplicates
    const updatedFormula = `${outcome} ~ ${uniqueTerms.join(" + ")}`;
    return updatedFormula;
}



        async function suggestAndUpdateModel(userInput) {
            const matchedKeys = await suggestModel(userInput); // call GPT
            const newFormula = generateUpdatedFormula(matchedKeys); // append missing features

            console.log("Updated formula:", newFormula);
            return newFormula;
        }





        function renderScatterPlot(container, featureX, featureY, featureX_Name, featureY_Name, dataSubset = dataset, classFeature = null, colorScale = null) {
        
            addRemoveButton(d3.select(container));

            const size = 200;
            const margin = { top: 10, right: 10, bottom: 40, left: 40 };
            const width = size - margin.left - margin.right;
            const height = size - margin.top - margin.bottom;

            const isPrediction = featureX.startsWith('pred') || featureY.startsWith('pred'); // Check for prediction features
            const isResidual = featureX.startsWith('residual') || featureY.startsWith('residual');

            const pointColor = isResidual 
                ? residual_col 
                : (isPrediction ? predictChart_col : baseChart_col);

            // Set the plot type as scatterplot
            d3.select(container)
                .attr("data-plot-type", "scatterplot")
                .attr("data-feature-x", featureX)
                .attr("data-feature-y", featureY) // Store the non-predicted feature

            const x = d3.scaleLinear()
                .domain(d3.extent(dataSubset, d => +d[featureX]))
                .range([margin.left, width + margin.left]);
            
            const y = d3.scaleLinear()
                .domain(d3.extent(dataSubset, d => +d[featureY]))
                .range([height + margin.top, margin.top]);

            const svg = d3.select(container)
                .append("svg")
                .attr("width", size)
                .attr("height", size)
                .attr("class", "scatter-plot"); // Add class for identification

            // Create a group for the points
            const pointsGroup = svg.append("g")
                .attr("class", "points-group");

            // sort by brightness if there are multiple colors
            const sortedData = (classFeature && colorScale) 
                ? dataSubset.sort((a, b) => d3.hsl(colorScale(a[classFeature])).l - d3.hsl(colorScale(b[classFeature])).l) 
                : dataSubset;

            // Create circles for scatterplot
            const circles = pointsGroup.selectAll("circle")
                //.data(dataSubset)
                .data(sortedData)
                .enter()
                .append("circle")
                .attr("class", "scatter-point")  // Add class for easier selection
                .attr("cx", d => x(d[featureX]))
                .attr("cy", d => y(d[featureY]))
                .attr("r", 3)
                //.attr("fill", pointColor)
                .attr("fill", d => (classFeature && colorScale) ? colorScale(d[classFeature]) : pointColor)
                .attr("data-original-color", d => { // Store color for later use
                    return (classFeature && colorScale) ? colorScale(d[classFeature]) : pointColor;
                })
                .attr("opacity", 0.5)
                .attr("data-index", (d, i) => i);  // Store index for linking

            // Create axes
            const xAxis = d3.axisBottom(x).tickSize(3);
            const yAxis = d3.axisLeft(y).tickSize(2); 

            // Append axes
            const gX = svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${height + margin.top})`)
                .call(xAxis);

            const gY = svg.append("g")
                .attr("class", "y-axis")
                .attr("transform", `translate(${margin.left},0)`)
                .call(yAxis);

            // Add labels
            const xLabel = svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.left)
                .attr("y", size - 5)
                .text(featureX_Name);

            const yLabel = svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", 15)
                .text(featureY_Name);

            // Create brush behavior
            const brush = d3.brush()
                .extent([[0, 0], [size, size]])
                .on("start", brushStarted)
                .on("brush", brushed)
                .on("end", brushEnded);

            // Add brush to a new group
            svg.append("g")
                .attr("class", "brush")
                .call(brush);

                function brushStarted(event) {
                    // If no valid event or source event, exit the function
                    if (!event.sourceEvent) return;

                    // If this brush is starting, clear all other brushes
                    const currentBrush = event.sourceEvent.target;
                    
                    d3.selectAll(".brush").each(function() {
                        // Skip the current brush
                        if (this !== currentBrush.parentNode) {
                            // Clear the brush
                            d3.select(this).call(brush.move, null);
                        }
                    });
                }

                function brushed(event) {
                    if (!event.selection) return; // Skip if no selection
                    
                    // Get the brush selection coordinates
                    const [[x0, y0], [x1, y1]] = event.selection;
                    
                    // Clear the global highlightedIndices
                    highlightedIndices.clear();

                    zoomedData = dataSubset.filter(d => {
                        const cx = x(d[featureX]);
                        const cy = y(d[featureY]);
                        return cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1;
                    });

                    // Update highlight
                    //pointsGroup.selectAll(".scatter-point").attr("opacity", d => zoomedData.includes(d) ? 1 : 0.2);

                    //zoomButton.style("background", zoomedData.length > 0 ? "#d3d3d3" : "#eee");

                    pointsGroup.selectAll(".scatter-point").each(function(d, i) {
                        const circle = d3.select(this);
                        const cx = +circle.attr("cx");
                        const cy = +circle.attr("cy");
                        
                        if (cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1) {
                            highlightedIndices.add(i);
                        }
                    });

                    // Update the visual highlights
                    updateHighlights();

                }

                function brushEnded(event) {
                    if (!event.selection) {
                        zoomedData = dataSubset;
                        //zoomButton.style("background", "#eee");
                        // If no selection, reset all points across all plots
                        d3.selectAll(".scatter-plot .scatter-point")
                            .style("fill", function () {
                                const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature-y");
                                const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-feature-x");

                                let originalColor = d3.select(this).attr("data-original-color");

                                // Determine original color
                                return featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred')
                                    ? predictChart_col // Predicted variable color
                                    : originalColor; // original color
                            });

                        // Clear frequency highlights
                        d3.selectAll(".highlighted-bar.frequency").remove();

                        // Reset average bars to the full dataset
                        d3.selectAll(".bar-chart").each(function () {
                            const barSvg = d3.select(this);
                            const categoricalFeature = barSvg.attr("data-feature-x");
                            const continuousFeature = barSvg.attr("data-continuous-feature");

                            if (continuousFeature) {
                                // Compute averages for the full dataset
                                const fullDataAverages = d3.rollups(
                                    dataSubset,
                                    v => d3.mean(v, d => +d[continuousFeature]),
                                    d => d[categoricalFeature]
                                ).map(([key, value]) => ({ category: key, average: value || 0 }));

                                const allCategories = fullDataAverages.map(d => d.category);

                                const margin = { top: 10, right: 10, bottom: 40, left: 40 };
                                const size = 200;

                                const x = d3.scaleBand()
                                    .domain(allCategories)
                                    .range([margin.left, size - margin.right])
                                    .padding(0.1);

                                const yAverage = d3.scaleLinear()
                                    .domain([0, d3.max(fullDataAverages, d => d.average) || 1])
                                    .range([size - margin.bottom, margin.top]);

                                // Update average bars
                                barSvg.selectAll("rect")
                                    .data(fullDataAverages, d => d.category)
                                    .join(
                                        enter => enter.append("rect")
                                            .attr("x", d => x(d.category))
                                            .attr("y", d => yAverage(d.average))
                                            .attr("width", x.bandwidth())
                                            .attr("height", d => size - margin.bottom - yAverage(d.average))
                                            .attr("fill", "blue"),
                                        update => update
                                            .attr("y", d => yAverage(d.average))
                                            .attr("height", d => size - margin.bottom - yAverage(d.average)),
                                        exit => exit.remove()
                                    );

                                // Reset y-axis
                                barSvg.select(".y-axis").call(d3.axisLeft(yAverage).tickSize(2));

                                // Reset x-axis (optional, for consistency)
                                barSvg.select(".x-axis")
                                    .attr("transform", `translate(0,${size - margin.bottom})`)
                                    .call(d3.axisBottom(x).tickSize(3));
                            }
                        });


                    }
                }


            // Add line toggle button
            const toggleButton = d3.select(container)
                .append("div")
                .attr("class", "toggle-line-button")
                .style("position", "absolute")
                .style("top", "-15px")
                .style("left", "30px")
                .style("padding", "2px 6px")
                .style("background", "lightgrey")
                .style("color", "black")
                .style("text-align", "center")
                .style("font-size", "12px")
                .style("border-radius", "3px")
                .style("border", "1px solid #aaa")
                .style("cursor", "pointer")
                .text("Line");


            let lineVisible = false;

            // Calculate linear regression and CI
            const xVals = dataSubset.map(d => d[featureX]);
            const yVals = dataSubset.map(d => d[featureY]);
            const n = xVals.length;
            const xMean = d3.mean(xVals);
            const yMean = d3.mean(yVals);
            const slope = d3.sum(xVals.map((x, i) => (x - xMean) * (yVals[i] - yMean))) / d3.sum(xVals.map(x => (x - xMean) ** 2));
            const intercept = yMean - slope * xMean;

            // Regression line data
            const xRange = d3.extent(xVals);
            const lineData = xRange.map(x => ({
                x: x,
                y: slope * x + intercept
            }));

            // Append line and CI paths (initially hidden)
            const line = svg.append("line")
                .attr("x1", x(lineData[0].x))
                .attr("y1", y(lineData[0].y))
                .attr("x2", x(lineData[1].x))
                .attr("y2", y(lineData[1].y))
                .attr("stroke", "red")
                .attr("stroke-width", 1.5)
                .attr("class", "regression-line")
                .style("display", "none");

            // 95% CI shaded area
            const tVal = 1.96; // Approx for 95%
            const sse = d3.sum(yVals.map((y, i) => (y - (slope * xVals[i] + intercept)) ** 2));
            const se = Math.sqrt(sse / (n - 2));

            const ciData = xVals.map(xi => {
                const yPred = slope * xi + intercept;
                const sePred = se * Math.sqrt(1 / n + ((xi - xMean) ** 2) / d3.sum(xVals.map(x => (x - xMean) ** 2)));
                return {
                    x: xi,
                    y0: yPred - tVal * sePred,
                    y1: yPred + tVal * sePred
                };
            }).sort((a, b) => a.x - b.x);

            const ciArea = d3.area()
                .x(d => x(d.x))
                .y0(d => y(d.y0))
                .y1(d => y(d.y1));

            const ciPath = svg.append("path")
                .datum(ciData)
                .attr("class", "ci-area")
                .attr("fill", "black")
                .attr("opacity", 0.1)
                .attr("d", ciArea)
                .style("display", "none");

            // Toggle behavior
            toggleButton.on("click", () => {
                lineVisible = !lineVisible;
                line.style("display", lineVisible ? "inline" : "none");
                ciPath.style("display", lineVisible ? "inline" : "none");
            });


            // drop categorical feature
            d3.select(container)
                .on("dragover", event => event.preventDefault())
                .on("dragover", function (event) {
                    event.preventDefault();
                    // Add a visual border
                    d3.select(this)
                        .style("border", "2px dashed #666")
                        .style("border-radius", "8px");
                })
                .on("dragleave", function (event) {
                    // Remove the border when dragging leaves the area
                    d3.select(this).style("border", null);
                })
                .on("drop", function(event) {
                    event.preventDefault();
                    d3.select(this).style("border", null);

                    const feature = JSON.parse(event.dataTransfer.getData("feature"));

                    // Only handle categorical feature drops
                    if (feature.type !== "categorical") return;

                    const container = this;
                    const parentArea = container.parentNode;

                    // Get current x and y from the container's attributes
                    const xFeature = d3.select(container).attr("data-feature-x");
                    const yFeature = d3.select(container).attr("data-feature-y");

                    // Ensure this container is a scatterplot
                    const plotType = d3.select(container).attr("data-plot-type");
                    if (plotType !== "scatterplot") return;

                    // Remove the current scatterplot
                    d3.select(container).remove();

                    const categories = [...new Set(dataset.map(d => d[feature.key]))];
                    const colorScale = d3.scaleOrdinal().domain(categories).range(d3.schemeCategory10);

                    categories.forEach(category => {
                        const filteredData = dataset.filter(d => d[feature.key] === category);

                        const chartId = `chart-${xFeature}-${category}-${Date.now()}`;
                        const newContainer = d3.select(parentArea)
                            .append("div")
                            .attr("class", "plot-container")
                            .attr("id", chartId)
                            .attr("draggable", true)
                            .attr("data-feature-x", xFeature)
                            .attr("data-feature-y", yFeature)
                            .attr("data-plot-type", "scatterplot")
                            .style("position", "relative")
                            .style("width", "200px")
                            .style("height", "200px")
                            .style("margin", "20px")
                            .node();

                        renderScatterPlot(
                            newContainer,
                            xFeature,
                            yFeature,
                            features.find(f => f.key === xFeature)?.name || xFeature,
                            features.find(f => f.key === yFeature)?.name || yFeature,
                            filteredData,
                            null,
                            d3.scaleOrdinal().domain([category]).range([colorScale(category)])
                        );

                        // labels
                        d3.select(newContainer)
                            .append("div")
                            .style("position", "absolute")
                            .style("top", "3px")
                            .style("right", "5px")
                            .style("background", "#eee")
                            .style("padding", "2px 6px")
                            .style("font-size", "10px")
                            .style("border-radius", "3px")
                            .text(category);
                    });
                });
        
        }

/*
        function renderAverageBarChart(container, categoricalFeature, continuousFeature, cateName, contName) {

            addRemoveButton(d3.select(container));
               
            const size = 200;
            const margin = { top: 10, right: 10, bottom: 40, left: 40 };
            const width = size - margin.left - margin.right;
            const height = size - margin.top - margin.bottom;
    
            d3.select(container)
                .attr("data-plot-type", "avg-bar")
                .attr("data-feature-y", categoricalFeature) 
    
            const isPrediction = continuousFeature.startsWith('pred'); 
            const pointColor = isPrediction ? predictChart_col : bar_col; 
    
            const data = d3.rollups(
                dataset,
                v => d3.mean(v, d => +d[continuousFeature]),
                d => d[categoricalFeature]
            ).map(([key, value]) => ({ category: key, average: value }));
    
            const x = d3.scaleBand()
                .domain(data.map(d => d.category))
                .range([margin.left, width + margin.left])
                .padding(0.1);
    
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.average)])
                .range([height + margin.top, margin.top]);
    
            const svg = d3.select(container).append("svg")
                .attr("width", size)
                .attr("height", size)
                .attr("class", "bar-chart")
                .attr("data-feature-x", categoricalFeature) // Add the categorical feature
                .attr("data-continuous-feature", continuousFeature); // Add the continuous feature
    
            svg.selectAll("rect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", d => x(d.category))
                .attr("y", d => y(d.average))
                .attr("width", x.bandwidth())
                .attr("height", d => height + margin.top - y(d.average))
                .attr("fill", pointColor);
    
            xAxis = svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${height + margin.top})`)
                .call(d3.axisBottom(x).tickSize(3));
            
            const numCategories = data.length;
    
            xAxis.selectAll("text")
                .attr("text-anchor", numCategories > 4 ? "end" : "middle") // Rotate only if more than 4 categories
                .attr("dx", numCategories > 4 ? "0.7em" : "0") 
                .attr("dy", numCategories > 4 ? "0.40em" : "0.35em")
                .attr("transform", function () {
                    return numCategories > 4 ? "rotate(-20)" : ""; // Rotate only when necessary
                });
    
            svg.append("g")
                .attr("class", "y-axis")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickSize(2));
    
            // Labels
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.left)
                .attr("y", size - 5)
                .text(cateName);
    
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", 15)
                .text(`Avg. ${contName}`);
        
        }
        */

        function renderAverageBarChart(container, categoricalFeature, continuousFeature, cateName, contName, dataSubset = dataset) {
            addRemoveButton(d3.select(container));
            d3.select(container).style("position", "relative");

            // Add chart type switch dropdown
            const dropdown = document.createElement("select");
            dropdown.className = "chart-switch";
            dropdown.style.position = "absolute";
            dropdown.style.top = "-15px";
            dropdown.style.right = "4px";
            dropdown.style.fontSize = "10px";

            ["avg-bar", "v-scatter"].forEach(type => {
                const option = document.createElement("option");
                option.value = type;
                option.textContent = type === "avg-bar" ? "Average" : "Distribution";
                dropdown.appendChild(option);
            });

            container.appendChild(dropdown);

            dropdown.onchange = (e) => {
                const selected = e.target.value;
                const containerParent = e.target.parentNode;

                // Clear current chart
                containerParent.querySelector("svg")?.remove();
                containerParent.querySelector(".remove-btn")?.remove(); // remove previous remove button

                // Re-render based on selection
                if (selected === "avg-bar") {
                    renderAverageBarChart(containerParent, categoricalFeature, continuousFeature, cateName, contName, dataSubset);
                } else if (selected === "v-scatter") {
                    renderVerticalScatterPlot(containerParent, categoricalFeature, continuousFeature, cateName, contName, dataSubset);
                }
            };


            const size = 200;
            const margin = { top: 10, right: 10, bottom: 40, left: 40 };
            const width = size - margin.left - margin.right;
            const height = size - margin.top - margin.bottom;

            d3.select(container)
                .attr("data-plot-type", "avg-bar")
                .attr("data-feature-x", categoricalFeature)
                .attr("data-feature-y", continuousFeature)
                .classed("bar-chart", true);;

            const isPrediction = continuousFeature.startsWith('pred');
            const pointColor = isPrediction ? predictChart_col : bar_col;

            // Compute mean and confidence interval
            const grouped = d3.rollups(
                dataSubset,
                v => {
                    const n = v.length;
                    const mean = d3.mean(v, d => +d[continuousFeature]);
                    const std = d3.deviation(v, d => +d[continuousFeature]);
                    const se = std / Math.sqrt(n);
                    const margin = 1.96 * se; // ~95% CI
                    return {
                        mean,
                        n,
                        lower: mean - margin,
                        upper: mean + margin
                    };
                },
                d => d[categoricalFeature]
            );

            //const data = grouped.map(([category, stats]) => ({ category, ...stats }));

            // Sort based on custom order if available, else alphabetical
            const data = grouped
                .sort((a, b) => {
                    const customOrder = customCategoryOrder[categoricalFeature];
                    if (customOrder) {
                        return customOrder.indexOf(a[0]) - customOrder.indexOf(b[0]);
                    }
                    return d3.ascending(a[0], b[0]);
                })
                .map(([category, stats]) => ({ category, ...stats }));

            const x = d3.scaleBand()
                .domain(data.map(d => d.category))
                .range([margin.left, width + margin.left])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([
                    Math.min(0, d3.min(data, d => d.lower)),
                    d3.max(data, d => d.upper)
                ])
                .nice()
                .range([height + margin.top, margin.top]);

            const svg = d3.select(container).append("svg")
                .attr("width", size)
                .attr("height", size)
                .attr("class", "bar-chart")
                .attr("data-feature-x", categoricalFeature)
                .attr("data-continuous-feature", continuousFeature);

            // Average bars
            svg.selectAll("rect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", d => x(d.category))
                .attr("y", d => Math.min(y(d.mean), y(0)))
                .attr("width", x.bandwidth())
                .attr("height", d => Math.abs(y(d.mean) - y(0)))
                .attr("fill", pointColor)
                .attr("data-category", d => d.category);

            // Error bars
            const errorBarWidth = x.bandwidth() / 4;

            svg.selectAll(".error-line")
                .data(data)
                .enter()
                .append("line")
                .attr("class", "error-line")
                .attr("x1", d => x(d.category) + x.bandwidth() / 2)
                .attr("x2", d => x(d.category) + x.bandwidth() / 2)
                .attr("y1", d => y(d.lower))
                .attr("y2", d => y(d.upper))
                .attr("stroke", "black")
                .attr("stroke-width", 1.2);

            // Error bar caps (top & bottom)
            svg.selectAll(".error-cap-top")
                .data(data)
                .enter()
                .append("line")
                .attr("x1", d => x(d.category) + x.bandwidth() / 2 - errorBarWidth / 2)
                .attr("x2", d => x(d.category) + x.bandwidth() / 2 + errorBarWidth / 2)
                .attr("y1", d => y(d.upper))
                .attr("y2", d => y(d.upper))
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            svg.selectAll(".error-cap-bottom")
                .data(data)
                .enter()
                .append("line")
                .attr("x1", d => x(d.category) + x.bandwidth() / 2 - errorBarWidth / 2)
                .attr("x2", d => x(d.category) + x.bandwidth() / 2 + errorBarWidth / 2)
                .attr("y1", d => y(d.lower))
                .attr("y2", d => y(d.lower))
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Axes
            const xAxis = svg.append("g")
            .attr("transform", `translate(0,${y(0)})`)
                .call(d3.axisBottom(x).tickSize(3));

            const numCategories = data.length;
            xAxis.selectAll("text")
                .attr("text-anchor", numCategories > 4 ? "end" : "middle")
                .attr("dx", numCategories > 4 ? "0.7em" : "0")
                .attr("dy", numCategories > 4 ? "0.40em" : "0.35em")
                .attr("transform", numCategories > 4 ? "rotate(-20)" : "");

            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickSize(2));

            // Labels
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.left)
                .attr("y", size - 5)
                .text(cateName);

            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2 - margin.top)
                .attr("y", 15)
                .text(`Avg. ${contName}`);


            // drop categorical feature on avg-bar chart
            d3.select(container)
                .on("dragover", event => event.preventDefault())
                .on("dragover", function (event) {
                    event.preventDefault();
                    d3.select(this)
                        .style("border", "2px dashed #666")
                        .style("border-radius", "8px");
                })
                .on("dragleave", function (event) {
                    d3.select(this).style("border", null);
                })
                .on("drop", function (event) {
                    event.preventDefault();
                    d3.select(this).style("border", null);

                    const feature = JSON.parse(event.dataTransfer.getData("feature"));
                    if (feature.type !== "categorical") return;

                    const container = this;
                    const parentArea = container.parentNode;

                    // Ensure this container is an average bar chart
                    const plotType = d3.select(container).attr("data-plot-type");
                    if (plotType !== "avg-bar") return;

                    // Get the original feature keys
                    const xFeature = d3.select(container).attr("data-feature-x");  // categorical
                    const yFeature = d3.select(container).select("svg").attr("data-continuous-feature"); // continuous

                    if (!xFeature || !yFeature) return;

                    // Remove the original average bar chart
                    d3.select(container).remove();

                    // Get all categories and sort alphabetically or via custom order
                    let categories = [...new Set(dataset.map(d => d[feature.key]))];

                    const customOrder = customCategoryOrder[feature.key];
                    if (customOrder) {
                        categories = customOrder.filter(cat => categories.includes(cat));
                    } else {
                        categories.sort(); // fallback: alphabetical
                    }

                    categories.forEach(category => {
                        const filteredData = dataset.filter(d => d[feature.key] === category);
                        const chartId = `chart-${xFeature}-${category}-${Date.now()}`;
                        const newContainer = d3.select(parentArea)
                            .append("div")
                            .attr("class", "plot-container")
                            .attr("id", chartId)
                            .attr("draggable", true)
                            .attr("data-feature-x", xFeature)
                            .attr("data-feature-y", yFeature)
                            .attr("data-plot-type", "avg-bar")
                            .style("position", "relative")
                            .style("width", "200px")
                            .style("height", "200px")
                            .style("margin", "20px")
                            .node();

                        renderAverageBarChart(
                            newContainer,
                            xFeature,
                            yFeature,
                            features.find(f => f.key === xFeature)?.name || xFeature,
                            features.find(f => f.key === yFeature)?.name || yFeature,
                            filteredData
                        );

                        // Add category label
                        d3.select(newContainer)
                            .append("div")
                            .style("position", "absolute")
                            .style("top", "3px")
                            .style("right", "5px")
                            .style("background", "#eee")
                            .style("padding", "2px 6px")
                            .style("font-size", "10px")
                            .style("border-radius", "3px")
                            .text(category);
                    });
                });

        }


        function renderVerticalScatterPlot(container, categoricalFeature, continuousFeature, cateName, contName, dataSubset = dataset) {

            const size = 200;
            const margin = { top: 10, right: 10, bottom: 40, left: 40 };
            const width = size - margin.left - margin.right;
            const height = size - margin.top - margin.bottom;

            d3.select(container)
                .attr("data-plot-type", "vertical-scatter")
                .attr("data-feature-y", categoricalFeature);

            const isPrediction = continuousFeature.startsWith('pred');
            const pointColor = isPrediction ? predictChart_col : baseChart_col;

            // Extract categories and apply custom or alphabetical ordering
            let categories = [...new Set(dataSubset.map(d => d[categoricalFeature]))];

            const customOrder = customCategoryOrder[categoricalFeature];
            if (customOrder) {
                categories = customOrder.filter(cat => categories.includes(cat));
            } else {
                categories.sort();
            }

            const x = d3.scaleBand()
                .domain(categories)
                .range([margin.left, width + margin.left])
                .padding(0.5); // Add space between categories

            const y = d3.scaleLinear()
                .domain(d3.extent(dataset, d => +d[continuousFeature]))
                .range([height + margin.top, margin.top]);

            const svg = d3.select(container).append("svg")
                .attr("width", size)
                .attr("height", size)
                .attr("class", "vertical-scatter");

            const jitterWidth = x.bandwidth() * 0.6;

            svg.selectAll("circle")
                .data(dataSubset)
                .enter()
                .append("circle")
                .attr("cx", d => x(d[categoricalFeature]) + x.bandwidth() / 2 + (Math.random() - 0.5) * jitterWidth)
                .attr("cy", d => y(+d[continuousFeature]))
                .attr("r", 2)
                .attr("fill", pointColor)
                .attr("opacity", 0.3)
                .attr("data-index", (d, i) => i); // for brushing/linking

            // X-axis
            const xAxis = svg.append("g")
                .attr("transform", `translate(0,${height + margin.top})`)
                .call(d3.axisBottom(x).tickSize(3));

            const numCategories = x.domain().length;
            xAxis.selectAll("text")
                .attr("text-anchor", numCategories > 4 ? "end" : "middle")
                .attr("dx", numCategories > 4 ? "0.7em" : "0")
                .attr("dy", numCategories > 4 ? "0.40em" : "0.35em")
                .attr("transform", numCategories > 4 ? "rotate(-20)" : "");

            // Y-axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickSize(2));

            // Labels
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.left)
                .attr("y", size - 5)
                .text(cateName);

            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2 - margin.top)
                .attr("y", 15)
                .text(contName);
        }

        function updateDataset(updated_dataset){
            // add predicted values (and residuals) to current dataset (to be used for plotting prediction and HOPs)

            const predPrefix = `pred${predCounter}_`; 

            // loop through 5 draws
            for (let i = 1; i <= 5; i++) {
                const predColumn = `${predPrefix}${i}`;
                //const predictedFeatureName = `Predicted (${predCounter})`;
                const predictedFeatureName = "Predicted " + features[0].name;
                
                dataset.forEach((d, index) => {
                    d[predColumn] = +updated_dataset[index][predColumn];
                    //d[residualColumn] = d[features[0].key] - d[predColumn]; // Assuming first feature is outcome 
                });

                const predictedFeature = 
                    {
                        name: predictedFeatureName,
                        key: predColumn,
                        type: "continuous"
                    };
                    
                features.push(predictedFeature);
                /*
                const residualColumn = `residual${predCounter}_${i}`;
                const residualFeatureName = `Residual (${predCounter})`;
                */

            }

        }


        function addResultPanel(formula, aic, rsq, dataset, updated_dataset) {
            updateDataset(updated_dataset)

            const resultsContainer = d3.select("#resultsContainer");

            // Extract outcome variable and predictors
            const formulaParts = formula.split("~").map(d => d.trim());
            const outcomeVar = formulaParts[0];  // Dependent variable
            const predictorVars = formulaParts[1].split("+").map(d => d.trim());  // Independent variables
            console.log(predictorVars)

            // Create a new panel for the model
            const panel = resultsContainer.append("div")
                .attr("class", "result-panel")
                .attr("panel_number", predCounter);

            // Create header container (Model Formula + Toggle)
            const headerContainer = panel.append("div")
                .attr("style", "display: flex; align-items: center; justify-content: space-between; cursor: pointer;")
                .on("click", function () {
                    // Toggle entire section (stats + scatterplots)
                    const content = d3.select(this.parentNode.querySelector(".result-content"));
                    content.style("display", content.style("display") === "none" ? "block" : "none");
                });

            // Create header (Model Formula)
            headerContainer.append("div")
                .attr("class", "result-header")
                .text(`Model ${predCounter}: ${formula}`);

            // Create content container for everything (stats + scatterplots)
            const content = panel.append("div")
                .attr("class", "result-content")
                .style("display", "none");  // Initially hidden

            // Create a button container for "Show Stat" and "Show Prediction"
            const buttonContainer = content.append("div")
                .style("display", "flex")
                .style("align-items", "center")
                .style("width", "100%");

            // Create "Show Stat" button
            const statButton = buttonContainer.append("button")
                .text("Show Stat")
                .style("padding", "5px 10px")
                .style("border", "none")
                .style("background", "lightgrey")
                .style("color", "black")
                .style("border-radius", "5px")
                .style("cursor", "pointer")
                .on("click", function () {
                    statContainer.style("display", statContainer.style("display") === "none" ? "inline" : "none");
                });

            // Create "Show Prediction" button and push it to the right
            const predictButton = buttonContainer.append("button")
                .text("Show Prediction")
                .style("margin-left", "auto")  // Push to the right
                .style("padding", "5px 10px")
                .style("border", "none")
                .style("background", "lightgrey")
                .style("color", "black")
                .style("border-radius", "5px")
                .style("cursor", "pointer")
                .on("click", function () {
                    // reveal HOPs button if currently hidden
                    const hopsButton = document.getElementById("toggleHOPsBtn");
                    if (hopsButton.style.display === "none") {
                        hopsButton.style.display = "inline-block";

                        //  Attach event listener ONLY if it hasn't been added before
                        if (!hopsButton.dataset.listenerAdded) {
                            hopsButton.addEventListener("click", toggleHOPs);
                            hopsButton.dataset.listenerAdded = "true"; // Prevent duplicate listeners
                        }
                    }

                    const currentPanel = this.closest(".result-panel");
                    const panelNumber = currentPanel.getAttribute("panel_number");
                    const predicted_key = `pred${panelNumber}_1`
                    const predictedFeature = features.find(f => f.key === predicted_key);

                    renderPlot(visArea, predictedFeature);

                });

            // Create a hidden stats container for AIC & R²
            const statContainer = content.append("div")
                .attr("class", "stat-content")
                .style("display", "none") // Hidden by default
                .style("margin-top", "5px")
                .style("font-size", "14px")
                .style("color", "#333")
                .text(` AIC: ${aic}, R²: ${rsq}`);

            // drop area for feature
            const dropBox = content.append("div")
                .attr("class", "feature-drop-box")
                .style("width", "300px")
                .style("height", "10px")
                .style("border", "2px dashed #aaa")
                .style("border-radius", "5px")
                .style("margin-top", "10px")
                .style("margin-bottom", "5px")
                .style("margin-left", "auto")
                .style("padding", "5px")
                .style("display", "flex")
                .style("align-items", "center")
                .style("justify-content", "center")
                .style("font-size", "10px")  
                .style("background-color", "#fafafa")
                .text("Drop a feature here for subgroup chart");

            dropBox
                .on("dragover", event => event.preventDefault())
                .on("dragenter", () => dropBox.style("background-color", "#f0f0f0"))
                .on("dragleave", () => dropBox.style("background-color", ""))
                .on("drop", event => {
                    event.preventDefault();
                    dropBox.style("background-color", "");

                    const feature = JSON.parse(event.dataTransfer.getData("feature"));
                    droppedFeature = feature;

                    dropBox.text(`Feature selected: ${feature.name}`);
                });


            // hypothesis table
            const hypoTableWrapper = content.append("div")
                .attr("class", "hypo-summary-wrapper")
                .style("margin-top", "10px");

            const table = hypoTableWrapper.append("table")
                .attr("class", "hypothesis-summary-table")
                .style("margin-top", "10px")
                .style("border", "1px solid #ccc")
                .style("width", "100%")
                .style("font-size", "12px");

            const headerRow = table.append("tr");
            headerRow.html("<th>ID</th><th>Query</th><th>Hypothesis</th><th>Group</th><th>Δ Price</th><th>Effect Size</th>");

            
            // Plot container (flexbox for horizontal stacking)
            const visAreaId = `visarea-panel-${predCounter}`;
            const visArea = content.append("div")
                .attr("id", visAreaId)
                .attr("class", "vis-area")
                .attr("style", "display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;")
                .on("dragover", event => event.preventDefault())
                .on("drop", function(event) {
                    event.preventDefault();
                    const feature = JSON.parse(event.dataTransfer.getData("feature"));
                    renderPlot(visArea, feature);

                });

            // Generate scatterplots for each predictor
            predictorVars.forEach(predictorVar => {
            console.log(predictorVar);
                if (predictorVar.includes(":")) { // if the term is an interaction term (still need to check continuous vs categorical)

                    const [key1, key2] = predictorVar.split(":").map(k => k.trim());
                    const feature1 = features.find(f => f.key === key1);
                    const feature2 = features.find(f => f.key === key2);

                    let featureX, featureY, featureXName, featureYName;

                    if (feature1.type === "categorical" && feature2.type === "continuous") {
                        featureX = key1;
                        featureY = key2;
                    } else if (feature1.type === "continuous" && feature2.type === "categorical") {
                        featureX = key2;
                        featureY = key1;
                    } else {
                        // If both same type or both categorical/continuous, default to key1:x, key2:y
                        featureX = key1;
                        featureY = key2;
                    }

                    featureXName = features.find(f => f.key === featureX)?.name || featureX;
                    featureYName = features.find(f => f.key === featureY)?.name || featureY;

                    

                    if (features.find(f => f.key === featureX).type === "continuous" &&
                        features.find(f => f.key === featureY).type === "continuous") {

                        const thisContainer = visArea.append("div")
                            .attr("class", "plot-container")
                            .style("position", "relative")
                            .style("width", "200px")
                            .style("height", "200px")
                            .style("margin", "20px")
                            .attr("data-feature-x", featureX);

                        renderScatterPlot(thisContainer.node(), featureX, featureY, featureXName, featureYName);

                    } else if (features.find(f => f.key === featureX).type === "categorical" &&
                        features.find(f => f.key === featureY).type === "continuous") {

                        const thisContainer = visArea.append("div")
                            .attr("class", "plot-container")
                            .style("position", "relative")
                            .style("width", "200px")
                            .style("height", "200px")
                            .style("margin", "20px")
                            .attr("data-feature-x", featureX);

                        renderAverageBarChart(thisContainer.node(), featureX, featureY, featureXName, featureYName);

                    }

                } else { // if the term is not an interaction term
                    console.log("main effect term");
                    const featureX = predictorVar;
                    const featureY = outcomeVar;
                    const featureXName = features.find(f => f.key === featureX)?.name || featureX;
                    const featureYName = features.find(f => f.key === featureY)?.name || featureY;

                    // Create container for scatterplot
                    const thisContainer = visArea.append("div")
                        .attr("class", "plot-container")
                        .style("position", "relative")
                        .style("width", "200px")
                        .style("height", "200px")
                        .style("margin", "20px")
                        .attr("data-feature-x", featureX);

                    if (features.find(f => f.key === featureX).type == 'continuous') {
                        renderScatterPlot(thisContainer.node(), featureX, featureY, featureXName, featureYName, dataset);
                    } else {
                        renderAverageBarChart(thisContainer.node(), featureX, featureY, featureXName, featureYName);
                        //renderVerticalScatterPlot(thisContainer.node(), featureX, featureY, featureXName, featureYName);
                        //renderViolinPlot(thisContainer.node(), featureX, featureY, featureXName, featureYName);

                    }
                }
            });

            predCounter++;

        }

        function toggleFeatureList() {
            const featureList = document.getElementById("feature-list");
            const button = document.getElementById("toggleFeatureBtn");

            if (featureList.style.display === "none" || featureList.style.display === "") {
                featureList.style.display = "flex"; // Show feature list
                button.textContent = "Hide Feature List";
            } else {
                featureList.style.display = "none"; // Hide feature list
                button.textContent = "Feature List";
            }
        }

        function addRemoveButton(container) {
            container.append("div")
                .attr("class", "remove-button")
                .style("position", "absolute")
                .style("top", "-15px")
                .style("left", "5px")
                .style("width", "18px")
                .style("height", "18px")
                .style("background", "lightgrey")
                .style("color", "black")
                .style("text-align", "center")
                .style("border-radius", "50%")
                .style("cursor", "pointer")
                .text("X")
                .on("click", function () {
                    const plotType = container.attr("data-plot-type"); // Get plot type
                    container.remove(); // Remove the chart
                });

                
        }

        function renderPlot(area, feature) {
            const chartId = `chart-${feature.key}-${Date.now()}`;
            const thisContainer = area.append("div")
                .attr("class", "plot-container")
                .attr("id", chartId) 
                .attr("draggable", true)
                .style("position", "relative")
                .style("width", "200px")
                .style("height", "200px")
                .style("margin", "20px")
                .attr("data-feature-x", feature.key)  // Store feature key for combining
                .on("dragstart", function(event) {
                    event.dataTransfer.setData("draggedFeature", JSON.stringify(feature));
                    event.dataTransfer.setData("chartId", chartId);
                })
                .on("dragover", event => event.preventDefault())
                .on("drop", function(event) {
                    event.preventDefault();
                    const draggedFeature = JSON.parse(event.dataTransfer.getData("draggedFeature"));
                    const draggedChartId = event.dataTransfer.getData("chartId");
                    const targetFeatureKey = d3.select(this).attr("data-feature-x");
                    const targetFeature = features.find(f => f.key === targetFeatureKey);

                    combinePlots(draggedFeature, targetFeature, this, draggedChartId);
                })
                .node();

            if (feature.type === "continuous") {
                renderDistributionPlot(thisContainer, feature.key, feature.name);
            } else if (feature.type === "categorical") {
                renderBarChart(thisContainer, feature.key, feature.name);
            }

            /*
                // Append dataset status label
                d3.select(plotContainer).append("div")
                    .attr("class", "dataset-status")
                    .style("text-align", "center")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("margin-bottom", "5px")
                    .text(document.getElementById("filter-message").textContent); 
                */

        }

        function renderDistributionPlot(container, featureKey, featureName) {

            container = d3.select(container)
            const size = 200;
            const margin = { top: 10, right: 10, bottom: 40, left: 40 };
            const width = size - margin.left - margin.right;
            const height = size - margin.top - margin.bottom;

            const isPrediction = featureKey.startsWith('pred'); // Check for prediction features
            const isResidual = featureKey.startsWith('residual');
            const pointColor = isPrediction ? predictChart_col : (isResidual ? residual_col : baseChart_col);

            // Set the plot type as distribution
            container.attr("data-plot-type", "distribution")
                    //.attr("id", chartId);

            // Preprocess the dataset for the specified feature
            const mappedData = dataset.map((d, i) => ({
                value: +d[featureKey], // Convert feature to numeric
                index: i               // Attach the original index
            }));

            const x = d3.scaleLinear()
                .domain(d3.extent(mappedData, d => d.value)) // Use the extent of the feature values
                .nice()
                .range([margin.left, size - margin.right]);        

            const bins = d3.histogram()
                .domain(x.domain())
                .thresholds(10)
                .value(d => d.value)(mappedData);

            bins.forEach((bin, i) => {
                bin.indices = bin.map(d => d.index); // Add indices for linking
            });

            const y = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .nice()
                .range([size - margin.bottom, margin.top]);

            const svg = container.append("svg")
                .attr("width", size)
                .attr("height", size)
                .attr("class", "distribution-plot");

            if (featureKey.startsWith('residual')) {
                svg.append("line")
                    .attr("x1", x(0))
                    .attr("x2", x(0))
                    .attr("y1", margin.top)
                    .attr("y2", size - margin.bottom)
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "4 2"); // Dashed line
            }

            // Draw histogram bars
            svg.append("g")
                .selectAll("rect")
                .data(bins)
                .enter().append("rect")
                .attr("x", d => x(d.x0) + 1)
                .attr("y", d => y(d.length))
                .attr("width", d => x(d.x1) - x(d.x0) - 1)
                .attr("height", d => y(0) - y(d.length))
                .attr("fill", pointColor)
                .attr("class", "histogram-bar")
                .attr("data-bin-indices", d => JSON.stringify(d.indices)); // Attach indices for linking
                
            // X-axis
            svg.append("g")
                .attr("transform", `translate(0,${size - margin.bottom})`)
                .call(d3.axisBottom(x).tickSize(3).ticks(5));

            // Y-axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickSize(3).ticks(5));

            // X-axis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.left)
                .attr("y", size - 5)
                .text(featureName);

            // Y-axis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2 - margin.top)
                .attr("y", 15)
                .text("Frequency");

            // Add remove button
            addRemoveButton(container);
        }



        function renderBarChart(container, featureKey, featureName) {
            container = d3.select(container);
            const size = 200;
            const margin = { top: 10, right: 10, bottom: 40, left: 40 };
            const width = size - margin.left - margin.right;
            const height = size - margin.top - margin.bottom;

            container.attr("data-plot-type", "barchart");
            
            const data = d3.rollups(
                dataset,
                v => ({
                    count: v.length,
                    indices: v.map((_, idx) => dataset.indexOf(v[idx])) // Use the original dataset index
                }),
                d => d[featureKey]
            ).map(([key, value]) => ({ category: key, ...value }));

            const x = d3.scaleBand()
                .domain(data.map(d => d.category))
                .range([margin.left, size - margin.right])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.count)])
                //.nice()
                .range([size - margin.bottom, margin.top]);

            const svg = container.append("svg")
                .attr("class", "bar-chart")
                .attr("data-feature-x", featureKey)
                .attr("width", size)
                .attr("height", size);

            let hoverIndices = new Set();
            
            // Draw background bars for the full dataset
            svg.selectAll(".background-bar")
                .data(data)
                .enter()
                .append("rect")
                .attr("class", "background-bar")
                .attr("x", d => x(d.category))
                .attr("y", d => y(d.count))
                .attr("width", x.bandwidth())
                .attr("height", d => y(0) - y(d.count))
                .attr("fill", "#c7c7c7") // Gray color for background bars
                .attr("data-indices", d => JSON.stringify(d.indices)) // Store indices for hover interaction
                .on("mouseover", function (event, d) {
                    // Track the currently hovered bar
                    currentHoveredBar = this;
                    
                    // Change bar color to orange
                    d3.select(this).attr("fill", brush_col);

                    
                    // Indices of the hovered bar
                    const hoveredIndices = new Set(d.indices);

                    // Update the global highlightedIndices
                    highlightedIndices = hoveredIndices;

                    // Highlight respective points in scatterplots
                    d3.selectAll(".scatter-plot .scatter-point, .vertical-scatter circle")
                        .style("fill", function () {
                            const pointIndex = +d3.select(this).attr("data-index");

                            // Highlight points matching the hovered bar
                            if (hoveredIndices.has(pointIndex)) {
                                return brush_col;
                            }

                            // Determine the original color of non-hovered points
                            const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature-y");
                            const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-feature-x");

                            return featureKeyX.startsWith("pred") || featureKeyY.startsWith("pred")
                                ? predictChart_col // Predicted variable color
                                : baseChart_col; // Default scatterplot color

                        });

                    // Update highlighted bars in other bar charts
                    d3.selectAll(".bar-chart").each(function () {
                        const barSvg = d3.select(this);
                        const categoricalFeature = barSvg.attr("data-feature-x");

                        // Skip the hovered chart
                        if (categoricalFeature === featureKey) return;

                        // Subset data for this bar chart
                        const filteredData = dataset.filter((_, i) => hoveredIndices.has(i));
                        const subset = d3.rollups(
                            filteredData,
                            v => v.length,
                            d => d[categoricalFeature]
                        ).map(([key, value]) => ({ category: key, count: value }));

                        // Get affected chart's data and categories
                        const affectedData = barSvg.selectAll(".background-bar").data();
                        const affectedCategories = affectedData.map(d => d.category);

                        // Align subset data with affected chart categories
                        const subsetComplete = affectedCategories.map(category => {
                            const found = subset.find(d => d.category === category);
                            return { category, count: found ? found.count : 0 };
                        });

                        const xAffected = d3.scaleBand()
                            .domain(affectedCategories)
                            .range([margin.left, size - margin.right])
                            .padding(0.1);

                        const yAffected = d3.scaleLinear()
                            .domain([0, d3.max(affectedData, d => d.count)])
                            .range([size - margin.bottom, margin.top]);

                        // Update highlighted bars
                        barSvg.selectAll(".highlighted-bar")
                            .data(subsetComplete, d => d.category)
                            .join(
                                enter => enter.append("rect")
                                    .attr("class", "highlighted-bar")
                                    .attr("x", d => xAffected(d.category))
                                    .attr("y", d => yAffected(d.count))
                                    .attr("width", xAffected.bandwidth())
                                    .attr("height", d => size - margin.bottom - yAffected(d.count))
                                    .attr("fill", brush_col)
                                    .style("opacity", 0.7),
                                update => update
                                    .attr("x", d => xAffected(d.category))
                                    .attr("y", d => yAffected(d.count))
                                    .attr("width", xAffected.bandwidth())
                                    .attr("height", d => size - margin.bottom - yAffected(d.count)),
                                exit => exit.remove()
                            );
                    });

                })
                .on("mouseout", function (event, d) {
                    // Reset bar color to gray
                    d3.select(this).attr("fill", "#c7c7c7");

                    // Clear global highlightedIndices
                    highlightedIndices.clear();

                    // Clear the hovered bar reference
                    currentHoveredBar = null;
                    
                    // Reset scatterplot points to default color
                    d3.selectAll(".scatter-plot .scatter-point, .vertical-scatter circle")
                        .style("fill", function () {
                            const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-feature-y");
                            const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature-x");

                            // Determine original color
                            return featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred')
                                ? predictChart_col // Predicted variable color
                                : baseChart_col; // Default color
                        });

                    // Clear highlighted bars in all bar charts
                    d3.selectAll(".bar-chart").selectAll(".highlighted-bar").remove();
                });

            // X-axis
            const xAxis = svg.append("g")
                .attr("transform", `translate(0,${size - margin.bottom})`)
                .call(d3.axisBottom(x).tickSize(3));

            // Count the number of categories
            const numCategories = data.length;

            // Rotate tick labels if necessary
            /*
            xAxis.selectAll("text")
                .attr("text-anchor", "end")
                .attr("dx", "0.7em")
                .attr("dy", "0.40em")
                .attr("transform", function () {
                    return this.textContent.length > 2 ? "rotate(-20)" : "";
                });
            */

            xAxis.selectAll("text")
            .attr("text-anchor", numCategories > 4 ? "end" : "middle") // Rotate only if more than 4 categories
            .attr("dx", numCategories > 4 ? "0.7em" : "0") 
            .attr("dy", numCategories > 4 ? "0.40em" : "0.35em")
            .attr("transform", function () {
                return numCategories > 4 ? "rotate(-20)" : ""; // Rotate only when necessary
            });

            // Y-axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickSize(2).ticks(5));

            // X-axis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.left)
                .attr("y", size - 5)
                .text(featureName);

            // Y-axis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2 - margin.top)
                .attr("y", 15)
                .text("Count");

            // Add remove button
            addRemoveButton(container);
        }

        function combinePlots(feature1, feature2, targetContainer, draggedChartId) {
        
            // Check if both features are the same, do not merge
            if (feature1.key === feature2.key) {
                return;
            }

            const isFeature1Continuous = feature1.type === "continuous";
            const isFeature2Continuous = feature2.type === "continuous";

            // Remove the dragged chart container
            
            const draggedFeatureKey = feature1.key;

            if (draggedChartId) {
                d3.select(`#${draggedChartId}`).remove();
            }
            // Clear existing plots in the container
            d3.select(targetContainer).selectAll("*").remove();

            /*
            // Re-add dataset status label after merging
            d3.select(targetContainer)
                .append("div")
                .attr("class", "dataset-status")
                .style("text-align", "center")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .style("margin-bottom", "5px")
                .text(document.getElementById("filter-message").textContent);
            */
            
            if (isFeature1Continuous && isFeature2Continuous) {

                renderScatterPlot(targetContainer, feature1.key, feature2.key, feature1.name, feature2.name);
            
            } else if (isFeature1Continuous && !isFeature2Continuous) {
            
                renderAverageBarChart(targetContainer, feature2.key, feature1.key, feature2.name, feature1.name);
            
            } else if (!isFeature1Continuous && isFeature2Continuous) {
            
                renderAverageBarChart(targetContainer, feature1.key, feature2.key, feature1.name, feature2.name);

            } else {
                alert("Cannot combine two categorical variables");
            }
            
        }

        function updateHighlights(classFeature = null, colorScale = null) {
            console.log("update highlights")
            // Update ALL scatter plots (change colors of they are brushed points)
            d3.selectAll(".scatter-plot .scatter-point")
                .style("fill", function () {
                    
                    const featureKeyX = d3.select(this).node().closest("div").getAttribute("data-feature-y");
                    const featureKeyY = d3.select(this).node().closest("div").getAttribute("data-feature-x");
                    const pointIndex = +d3.select(this).attr("data-index");
        
                    const isPrediction = featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred');
                    const isResidual = featureKeyX.startsWith('residual') || featureKeyY.startsWith('residual');

                    if (highlightedIndices.has(pointIndex)) {
                        return brush_col; // Highlight color
                    }
                    /*
                    return isResidual 
                        ? residual_col 
                        : (isPrediction ? predictChart_col : baseChart_col);
                    
                    // Determine the original color before highlighting
                    const originalColor = isResidual 
                        ? residual_col 
                        : (isPrediction ? predictChart_col : (classFeature && colorScale) ? colorScale(d[classFeature]) : baseChart_col);
                    */
                    let originalColor = d3.select(this).attr("data-original-color");
                    if (isResidual) {
                        originalColor = residual_col;
                    }
                    // If highlighted, change to brush color
                    return highlightedIndices.has(pointIndex) ? brush_col : originalColor;

                    /*if (featureKeyX.startsWith('pred') || featureKeyY.startsWith('pred')){
                        return highlightedIndices.has(pointIndex) ? brush_col : predictChart_col;
                    } else {
                        return highlightedIndices.has(pointIndex) ? brush_col : baseChart_col;
                    }*/

                });

            // Update all histogram bars
            d3.selectAll(".histogram-bar")
                .style("fill", function(d) {
                    const binIndices = d.indices || [];
                    const featureKeyX =d3.select(this).node().closest("div").getAttribute("data-feature-x");
                    //return binIndices.some(index => highlightedIndices.has(index)) ? brush_col : bar_col;
                    const defaultColor = featureKeyX.startsWith("pred") ? predictChart_col : baseChart_col;
                    const isHighlighted = binIndices.some(index => highlightedIndices.has(index));
                    return isHighlighted ? brush_col : defaultColor;

                });

            // Update bar charts (frequency-based and average-based)
            d3.selectAll(".highlighted-bar").remove(); // Clear old highlights
            d3.selectAll(".bar-chart").each(function () {
                const barSvg = d3.select(this);
                const categoricalFeature = barSvg.attr("data-feature-x");
                const continuousFeature = barSvg.attr("data-continuous-feature");

                const isFrequencyChart = !continuousFeature; // If no continuous feature, it's a frequency chart
                const isAverageChart = !!continuousFeature; // If continuous feature exists, it's an average chart

                const filteredData = dataset.filter((_, i) => highlightedIndices.has(i));
                
                // Frequency Chart Update
                if (isFrequencyChart) {
                    const brushedDataCounts = d3.rollups(
                        filteredData,
                        v => v.length,
                        d => d[categoricalFeature]
                    ).map(([key, value]) => ({ category: key, count: value }));

                    const margin = { top: 10, right: 10, bottom: 40, left: 40 };
                    const size = 200;

                    const x = d3.scaleBand()
                        .domain(barSvg.selectAll(".background-bar").data().map(d => d.category))
                        .range([margin.left, size - margin.right])
                        .padding(0.1);

                    const yFrequency = d3.scaleLinear()
                        .domain([0, d3.max(barSvg.selectAll(".background-bar").data(), d => d.count)])
                        .range([size - margin.bottom, margin.top]);

                    barSvg.selectAll(".highlighted-bar.frequency")
                        .data(brushedDataCounts, d => d.category)
                        .join(
                            enter => enter.append("rect")
                                .attr("class", "highlighted-bar frequency")
                                .attr("x", d => x(d.category))
                                .attr("y", d => yFrequency(d.count))
                                .attr("width", x.bandwidth())
                                .attr("height", d => size - margin.bottom - yFrequency(d.count))
                                .attr("fill", brush_col)
                                .style("opacity", 0.7),
                            update => update
                                .attr("y", d => yFrequency(d.count))
                                .attr("height", d => size - margin.bottom - yFrequency(d.count)),
                            exit => exit.remove()
                        );
                }

                // Average Chart Update
                if (isAverageChart && (filteredData.length > 0) ) {
                    const brushedDataAverages = d3.rollups(
                        filteredData,
                        v => d3.mean(v, d => +d[continuousFeature]),
                        d => d[categoricalFeature]
                    ).map(([key, value]) => ({ category: key, average: value || 0 }));

                    
                    const allCategories = d3.rollups(
                        dataSubset,
                        v => d3.mean(v, d => +d[continuousFeature]),
                        d => d[categoricalFeature]
                    ).map(([key, value]) => ({ category: key, average: value || 0 })).map(d => d.category);
                    
                    const completeAveragesData = allCategories.map(category => {
                        const found = brushedDataAverages.find(d => d.category === category);
                        return { category, average: found ? found.average : 0 }; // Fallback to 0 for missing categories
                    });

                    const margin = { top: 10, right: 10, bottom: 40, left: 40 };
                    const size = 200;

                    const x = d3.scaleBand()
                        .domain(barSvg.selectAll(".background-bar").data().map(d => d.category))
                        .range([margin.left, size - margin.right])
                        .padding(0.1);

                    const yAverage = d3.scaleLinear()
                        .domain([0, d3.max(completeAveragesData, d => d.average) || 1])
                        .range([size - margin.bottom, margin.top]);

                        barSvg.selectAll("rect")
                        .data(completeAveragesData, d => d.category)
                        .join(
                            enter => enter.append("rect")
                                .attr("x", d => x(d.category))
                                .attr("y", d => yAverage(d.average))
                                .attr("width", x.bandwidth())
                                .attr("height", d => size - margin.bottom - yAverage(d.average))
                                .attr("fill", "blue"),
                            update => update
                                .attr("y", d => yAverage(d.average))
                                .attr("height", d => size - margin.bottom - yAverage(d.average)),
                            exit => exit.remove()
                        );

                    const yAxis = d3.axisLeft(yAverage).tickSize(2);
                    barSvg.select(".y-axis")
                        .call(yAxis);
                }
            });

        }

        function toggleHOPs() {
            const button = document.getElementById("toggleHOPsBtn");

            if (isCycling) {
                clearInterval(predictionInterval);
                predictionInterval = null;
                isCycling = false;
                button.textContent = "Activate HOPs";
                button.classList.remove("active");
            } else {
                isCycling = true;
                button.textContent = "Deactivate HOPs";
                button.classList.add("active");

                predictionInterval = setInterval(() => {
                    const savedHighlights = new Set(highlightedIndices);

                    d3.selectAll(".plot-container").each(function () {
                        const container = this;
                        const featureKey = d3.select(container).attr("data-feature-x");
                        const otherFeatureKey = d3.select(container).attr("data-feature-y");
                        const plotType = d3.select(container).attr("data-plot-type");

                        const newFeatureKey = featureKey.startsWith("pred") || featureKey.startsWith("residual")
                            ? `${featureKey.split("_")[0]}_${currentPredictionIndex}`
                            : featureKey;

                        const newOtherFeatureKey = otherFeatureKey && (otherFeatureKey.startsWith("pred") || otherFeatureKey.startsWith("residual"))
                            ? `${otherFeatureKey.split("_")[0]}_${currentPredictionIndex}`
                            : otherFeatureKey;

                        if (featureKey !== newFeatureKey || otherFeatureKey !== newOtherFeatureKey) {
                            const feature = features.find(f => f.key === newFeatureKey);
                            const otherFeature = features.find(f => f.key === newOtherFeatureKey);

                            if (feature) {
                                d3.select(container).selectAll("*").remove();

                                if (plotType === "scatterplot") {
                                    renderScatterPlot(container, newOtherFeatureKey, newFeatureKey, otherFeature.name, feature.name);
                                } else if (plotType === "distribution") {
                                    renderDistributionPlot(container, newFeatureKey, feature.name);
                                } else if (plotType === "bar-chart") {
                                    renderBarChart(container, newFeatureKey, feature.name);
                                } else if (plotType === "avg-bar") {
                                    renderAverageBarChart(container, newOtherFeatureKey, newFeatureKey, otherFeature.name, feature.name);
                                }
                            }
                        }
                    });

                    if (currentHoveredBar) {
                        d3.select(currentHoveredBar).dispatch("mouseover");
                    }

                    highlightedIndices = savedHighlights;
                    currentPredictionIndex = (currentPredictionIndex % 5) + 1;
                    updateHighlights();
                }, 1000);
            }
        }

        function showInitialBotMessage() {
            const chatbox = document.getElementById("chatbox");
            const botMessage = document.createElement("div");
            botMessage.classList.add("message", "bot");
            botMessage.textContent = "You’re exploring air travel pricing data. Which variables do you think play a role in ticket price?";
            chatbox.appendChild(botMessage);
            chatbox.scrollTop = chatbox.scrollHeight;            
        }

        // extract mean formula from resuilt-panel based on model number
        function extractFormula(model_number) {
            const headerSelector = `.result-panel[panel_number="${model_number}"] .result-header`;
            const headerElement = document.querySelector(headerSelector);
            const headerText = headerElement?.textContent || "";
            const formulaMatch = headerText.match(/Model \d+:\s*(.+)/);
            const formula = formulaMatch[1].trim();

            return formula
        }

        function createHypoObj(model_number) {
            hypothesesObject = {};

            const formulaMean = extractFormula(model_number);
            console.log(formulaMean);
            const [dependentVariable, predictors] = formulaMean.split('~').map(s => s.trim());

            // Split terms and identify interaction terms
            const expandedTerms = predictors
                .split('+')
                .map(term => term.trim())
                .filter(Boolean); // Remove empty strings

            const interactionTerms = expandedTerms.filter(term => term.includes(':'));
            const independentVariables = expandedTerms
                .filter(term => !term.includes(':') )
                .map(term => term.trim())
                .filter(Boolean);

            console.log('interactionTerms: ', interactionTerms);
            console.log('independentVariables: ', independentVariables)

            // Deduplicate independent variables
            const uniqueIndependentVariables = [...new Set(independentVariables)];

            // Identify categorical variables
            const categoricalVariables = uniqueIndependentVariables.filter(p => {
                const feature = features.find(f => f.key === p);
                return feature && feature.type === 'categorical';
            });

            console.log('categoricalVariables: ', categoricalVariables);

            // Identify variables interacting with categorical variables
            const interactingWithCategorical = [];
            interactionTerms.forEach(term => {
                const components = term.split(':').map(s => s.trim());
                const categorical = components.find(comp => categoricalVariables.includes(comp));
                if (categorical) {
                    components.forEach(comp => {
                        if (comp !== categorical) {
                            interactingWithCategorical.push({ variable: comp, categorical });
                        }
                    });
                }
            });

            console.log('interactingWithCategorical: ', interactingWithCategorical);

            const uniqueInteractingWithCategorical = [...new Set(interactingWithCategorical.map(JSON.stringify))].map(JSON.parse);

            let hypothesisCounter = 1;
            let hypothesisSet = new Set(); // Set to store unique hypothesis strings

            function addHypothesis(hypothesis, type, testType, var1, var2, relevant_var) {
                if (!hypothesisSet.has(hypothesis)) { // Ensure uniqueness
                    hypothesesObject[`H${hypothesisCounter}`] = {
                        id: `H${hypothesisCounter}`,
                        hypothesis: hypothesis,
                        type: type,
                        testType: testType,
                        var1: var1,
                        var2: var2,
                        relevant_var: relevant_var
                    };
                    hypothesisSet.add(hypothesis); // Store in set to track duplicates
                    hypothesisCounter++;
                }
            }

            /*
            // Add independent variable hypotheses
            independentVariables.forEach(variable => {
                addHypothesis(
                    `${variable} significantly affects ${dependentVariable} (having non-zero slope).`,
                    "Main and Interaction",
                    "overall",
                    variable,
                    dependentVariable,
                    [variable, dependentVariable]
                );
            });
            */
            /*
            // Add interaction term hypotheses
            interactionTerms.forEach(term => {
                addHypothesis(
                    `${term} significantly improves model fit to predict ${dependentVariable}.`,
                    "Interaction Only",
                    "interaction",
                    term,
                    dependentVariable,
                    [dependentVariable]
                );
            });
            */

            // Add categorical variable level effects
            categoricalVariables.forEach(categorical => {
                addHypothesis(
                    `${dependentVariable} is significantly different for each pair of ${categorical}.`,
                    "Categorical Level",
                    "level_val",
                    dependentVariable,
                    categorical,
                    [dependentVariable, categorical]
                );
            });

            uniqueInteractingWithCategorical.forEach(({ variable, categorical }) => {
                const variableType = features.find(f => f.key === variable)?.type;
                const categoricalType = features.find(f => f.key === categorical)?.type;

                if (variableType === "continuous" || categoricalType === "continuous") {
                    // continuous × categorical interaction
                    addHypothesis(
                        `${variable} has a significant effect on ${dependentVariable} within each level of ${categorical}.`,
                        "Con x Cat Interaction",
                        "level_slope",
                        variable,
                        categorical,
                        [variable, categorical, dependentVariable]
                    );
                } 
                
                if (variableType === "categorical" && categoricalType === "categorical") {
                    // categorical1 × categorical2 interaction
                    addHypothesis(
                        `${variable} has a significant effect on ${dependentVariable} within each level of ${categorical}.`,
                        "Cat x Cat Interaction",
                        "level_val_interact",
                        variable,
                        categorical,
                        [variable, categorical, dependentVariable]
                    );

                    // categorical2 × categorical1 interaction
                    addHypothesis(
                        `${categorical} has a significant effect on ${dependentVariable} within each level of ${variable}.`,
                        "Cat x Cat Interaction",
                        "level_val_interact",
                        categorical,
                        variable,
                        [variable, categorical, dependentVariable]
                    );
                }
            });

            /*
            // Add interactions between continuous with categorical variables 
            uniqueInteractingWithCategorical.forEach(({ variable, categorical }) => {
                addHypothesis(
                    `${variable} has a significant effect on ${dependentVariable} within each level of ${categorical}.`,
                    "Con x Cat Interaction",
                    "level_slope",
                    variable,
                    categorical,
                    [variable, categorical, dependentVariable]
                );
            });

            // interaction between 2 categorical variables
            uniqueInteractingWithCategorical.forEach(({ variable, categorical }) => {
                addHypothesis(
                    `${variable} has a significant effect on ${dependentVariable} within each level of ${categorical}.`,
                    "Cat x Cat Interaction",
                    "level_val_interact",
                    variable,
                    categorical,
                    [variable, categorical, dependentVariable]
                );
            });
            */

            console.log('All possible Hypotheses from this model:', hypothesesObject);
        }

        async function matchHypo(userInput) {
            const formattedHypotheses = Object.values(hypothesesObject)
                .map(h => `ID: ${h.id}, Hypothesis: "${h.hypothesis}", Type: "${h.type}", TestType: "${h.testType}", var1: "${h.var1}", var2: "${h.var2}", relevant_var: ${JSON.stringify(h.relevant_var)}`)
                .join("\n");

            const featureKeys = features.map(f => f.key);
            const prompt = `
                You are a strict JSON generator. You only return raw JSON. No explanations, no headers, no markdown, no comments, ever.

                You are given:
                1. A list of dataset variable keys: ${JSON.stringify(featureKeys)}
                2. A user input: "${userInput}"
                3. A list of structured hypotheses (formatted as JSON-like lines): ${formattedHypotheses}

                Your task:
                - Step 1: Identify which variable keys from the dataset the user is referring to (even if misspelled or described differently).
                - Step 2: From the list of structured hypotheses, return only those where the "relevant_var" array contains ALL inferred variable keys.
                Example: If the inferred variables are ["A", "B", "C"], then only return hypotheses where relevant_var includes all three of those keys. Any hypothesis with just two of those (e.g. ["A", "B"]) must be excluded.
                If no match exists, return: {}

                Output format:

                Return ONLY the following JSON object. No explanation, no markdown, no preamble:
                
                {
                "H1": {
                    "id": "H1",
                    "hypothesis": "text",
                    "type": "Main and Interaction",
                    "testType": "overall",
                    "var1": "duration",
                    "var2": "price",
                    "relevant_var": ["duration", "price"]
                },
                "H3": {
                    "id": "H3",
                    "hypothesis": "text",
                    "type": "Categorical Level",
                    "testType": "level_val",
                    "var1": "class",
                    "var2": "price",
                    "relevant_var": ["class", "price"]
                }
                }

                If no match exists, return: {}

                NO OTHER TEXT.
                `;


            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${API_KEY}`
                },
                body: JSON.stringify({
                    model: gpt_model,
                    temperature: 0,
                    messages: [
                        { role: "system", content: "You are a helpful assistant who helps match hypotheses based on meaning." },
                        { role: "user", content: prompt }
                    ]
                })
            });

            const data = await response.json();

            /*
            const similarHypothesesJSON = data.choices[0].message.content.trim().replace(/```json/g, "").replace(/```/g, "").trim();
            console.log("match hypotheses:", similarHypothesesJSON)
            const similarHypotheses = JSON.parse(similarHypothesesJSON); // convert string to object
            */

            const gptText = data.choices[0].message.content.trim();
            console.log(gptText)

            // Clean up markdown-style formatting (```json ... ```)
            const cleaned = gptText.replace(/```json/g, "").replace(/```/g, "").trim();

            // Extract first JSON-like block
            const match = cleaned.match(/\{[\s\S]*\}/);
            similarHypotheses = JSON.parse(match[0]);
            console.log("✅ Parsed hypotheses:", similarHypotheses);

            if (Object.keys(similarHypotheses).length === 0) {
                console.log("No matched hypotheses!");

                //suggestAndUpdateModel(userInput)
                // extract relevant var from user input then print out some formulas that contains them
                // click button to fit

                // Suggest a new model

                const matchedKeys = await suggestModel(userInput);
                const updatedFormula = generateUpdatedFormula(matchedKeys);

                if (updatedFormula) {
                    const chatbox = document.getElementById("chatbox");

                    // Bot message with formula
                    const messageWrapper = document.createElement("div");
                    messageWrapper.classList.add("message", "bot");

                    const textSpan = document.createElement("span");
                    textSpan.textContent = `This model is not suitable for statistically testing your hypothesis. But here is a new model suggestion:\n${updatedFormula}  `;

                    const fitBtn = document.createElement("button");
                    fitBtn.textContent = "Fit";
                    fitBtn.style.marginLeft = "10px";
                    fitBtn.style.padding = "2px 6px";
                    fitBtn.style.fontSize = "12px";
                    fitBtn.style.cursor = "pointer";
                    fitBtn.style.borderRadius = "4px";
                    fitBtn.onclick = () => fitModel(updatedFormula);

                    messageWrapper.appendChild(textSpan);
                    messageWrapper.appendChild(fitBtn);

                    chatbox.appendChild(messageWrapper);
                    chatbox.scrollTop = chatbox.scrollHeight;
                }


            } else {
                // Show response in chat
                const chatbox = document.getElementById("chatbox");
                
                // 1. Intro message
                const introMessage = document.createElement("div");
                introMessage.classList.add("message", "bot");
                introMessage.textContent = "You can test the following Hypotheses:";
                chatbox.appendChild(introMessage);

                // 2. Each hypothesis in its own bubble            
                const hypotheses = Object.values(similarHypotheses)


                hypotheses.forEach(hypoObj => {

                    const { testType, hypothesis, var1, var2 } = hypoObj;

                    const hypoContainer = document.createElement("div");
                    hypoContainer.classList.add("message", "bot");

                    // Add text node
                    const hypoText = document.createElement("span");
                    hypoText.textContent = hypothesis;
                    hypoContainer.appendChild(hypoText);

                    // Add button
                    const testButton = document.createElement("button");
                    testButton.textContent = "Test This";
                    testButton.style.marginLeft = "10px";
                    testButton.style.padding = "2px 6px";
                    testButton.style.fontSize = "12px";
                    testButton.style.cursor = "pointer";

                    testButton.onclick = () => getHypoResult(userInput, hypothesis, hypoContainer, testType, var1, var2);  

                    hypoContainer.appendChild(testButton);
                    chatbox.appendChild(hypoContainer);
                });

                chatbox.scrollTop = chatbox.scrollHeight;

            }

        }

        async function getHypoResult(userInput, hypo, container, testType, var1, var2) {
            console.log("Testing this hypothesis:", hypo);

            const model_number = predCounter - 1;
            const this_formula = extractFormula(model_number);
            
            const test_result = await testHypothesis(this_formula, var1, var2, testType);
            console.log(test_result);

            ///// Store in global result
            // Append to existing or initialize if not present
            if (!testResultsByModel.has(model_number)) {
                testResultsByModel.set(model_number, []);
            }

            const storedResults = testResultsByModel.get(model_number);
            storedResults.push(...test_result); // Append new rows

            const allResults = testResultsByModel.get(model_number);  // all results for this model number

            console.log('testResultsByModel',testResultsByModel);
            console.log('allResults',allResults);

            /////

            // Find model panel
            const panel = document.querySelector(`.result-panel[panel_number="${model_number}"]`);
            if (!panel) return;

            const content = panel.querySelector(".result-content");
            const buttonContainer = content.querySelector("div");

            // Add Hypothesis Summary button if not already added
            let summaryButton = buttonContainer.querySelector(".hypothesis-summary-btn");
            if (!summaryButton) {
                summaryButton = document.createElement("button");
                summaryButton.textContent = "Hypothesis Summary";
                summaryButton.classList.add("hypothesis-summary-btn");
                summaryButton.style.marginLeft = "10px";
                summaryButton.style.padding = "5px 10px";
                summaryButton.style.border = "none";
                summaryButton.style.background = "lightgrey";
                summaryButton.style.color = "black";
                summaryButton.style.borderRadius = "5px";
                summaryButton.style.cursor = "pointer";

                summaryButton.onclick = () => {
                    const table = content.querySelector(".hypothesis-summary-table");
                    if (table) {
                        table.style.display = table.style.display === "none" ? "table" : "none";
                    }
                };

                buttonContainer.appendChild(summaryButton);
            }

            ////////////////////////////
            // Inline result message in same bubble
            ////////////////////////////

            const resultDiv = document.createElement("div");
            resultDiv.style.marginTop = "8px";
            resultDiv.style.fontWeight = "bold";

            let pval;

            if ((testType === 'overall') || (testType === 'interaction') ) {
                pval = test_result[0];
                if (pval == 0) {
                    pval = '< 0.0001'
                }

                if (pval > 0.05) {
                    resultDiv.style.color = "red";
                    resultDiv.textContent = "❌ The result is not statistically significant at the 0.05 level.";
                } else if ( pval <= 0.05 || pval == '< 0.0001' ) {
                    resultDiv.style.color = "green";
                    resultDiv.textContent = "✅ The result is statistically significant at the 0.05 level.";
                }

                container.appendChild(resultDiv);


            } else if (testType == 'level_val') {
                const allPValues = test_result.map(d => d["p.value"]);

                const allSignificant = allPValues.every(p => p <= 0.05);
                const allNotSignificant = allPValues.every(p => p > 0.05);

                if (allSignificant) {
                    resultDiv.style.color = "green";
                    resultDiv.textContent = "✅ The result is statistically significant at the 0.05 level for all contrasts.";
                } else if (allNotSignificant) {
                    resultDiv.style.color = "red";
                    resultDiv.textContent = "❌ The result is not statistically significant at the 0.05 level for all contrasts.";
                } else {
                    resultDiv.style.color = "orange";
                    resultDiv.textContent = "⚠️ The result is partially significant: some contrasts are significant while others are not.";
                }

                container.appendChild(resultDiv);

            } else if (testType == 'level_slope') {

                const allPValues = test_result.map(d => d["p.value"]);

                const allSignificant = allPValues.every(p => p <= 0.05);
                const allNotSignificant = allPValues.every(p => p > 0.05);

                if (allSignificant) {
                    resultDiv.style.color = "green";
                    resultDiv.textContent = "✅ The result is statistically significant at the 0.05 level for all categories.";
                } else if (allNotSignificant) {
                    resultDiv.style.color = "red";
                    resultDiv.textContent = "❌ The result is not statistically significant at the 0.05 level for all categories.";
                } else {
                    resultDiv.style.color = "orange";
                    resultDiv.textContent = "⚠️ The result is significant in some categories (but not all).";
                }

                container.appendChild(resultDiv);

            } else if (testType == 'level_val_interact') {

                const allPValues = test_result.map(d => d["p.value"]);

                const allSignificant = allPValues.every(p => p <= 0.05);
                const allNotSignificant = allPValues.every(p => p > 0.05);

                if (allSignificant) {
                    resultDiv.style.color = "green";
                    resultDiv.textContent = "✅ The result is statistically significant at the 0.05 level for all categories.";
                } else if (allNotSignificant) {
                    resultDiv.style.color = "red";
                    resultDiv.textContent = "❌ The result is not statistically significant at the 0.05 level for all categories.";
                } else {
                    resultDiv.style.color = "orange";
                    resultDiv.textContent = "⚠️ The result is significant in some categories (but not all).";
                }

                container.appendChild(resultDiv);
                
            }

            ////////////////////////////
            // Add table result
            ////////////////////////////
            
            let table = content.querySelector(".hypothesis-summary-table");
            table.querySelector("tbody")?.remove();

            // add each row from test_results to table
            if (testType === 'level_val_interact' || testType === 'level_val') {
                let tbody = table.querySelector("tbody");
                if (!tbody) {
                    tbody = document.createElement("tbody");
                    table.appendChild(tbody);
                }

                // Assign or retrieve label for this query
                if (!queryLabelMap[userInput]) {
                    queryLabelMap[userInput] = `Q${queryCounter++}`;
                }
                const queryLabel = queryLabelMap[userInput];

                const estimates = allResults.map(d => d.estimate);
                const maxAbs = Math.max(Math.abs(d3.min(estimates)), Math.abs(d3.max(estimates)));

                // Shared effect size scale across all rows
                const allEffectSizes = allResults.flatMap(d => [d["lower.CL"], d["upper.CL"]]);
                const minX = Math.min(...allEffectSizes);
                const maxX = Math.max(...allEffectSizes);

                const effectSizeScale = d3.scaleLinear()
                    .domain([minX, maxX])
                    .range([5, 115]); 


                allResults.forEach((obj, index) => {
                    const row = document.createElement("tr");

                    const idCell = document.createElement("td");
                    idCell.textContent = index + 1;

                    const queryCell = document.createElement("td");
                    queryCell.textContent = queryLabel;
                    queryCell.title = userInput;

                    const hypoCell = document.createElement("td");

                    let pval = obj["p.value"];
                    if (pval === 0 || pval < 0.0001) {
                        pval = "< 0.0001";
                    } else {
                        pval = pval.toFixed(4);
                    }

                    // Create color square based on p.value
                    const square = document.createElement("span");
                    square.style.display = "inline-block";
                    square.style.width = "10px";
                    square.style.height = "10px";
                    square.style.marginRight = "6px";
                    square.style.verticalAlign = "middle";
                    square.style.backgroundColor = obj["p.value"] <= 0.05 ? "lightgreen" : "red";
                    square.title = `p-value: ${pval}`;

                    // Add square + hypothesis text
                    const [cat1, cat2] = obj.contrast.split(" - ").map(s => s.trim());
                    hypoCell.appendChild(square);
                    hypoCell.appendChild(document.createTextNode("There is a significant difference between " + cat1 + " and " + cat2 + " " + obj.testVar + "."));

                    // group column
                    const groupCell = document.createElement("td");
                    if (testType === 'level_val_interact') {
                        const groupKey = Object.keys(obj).find(k => !["contrast", "estimate", "SE", "df", "t.ratio", "p.value"].includes(k));
                        groupCell.textContent = obj[groupKey];
                    } else if (testType === 'level_val') {
                        groupCell.textContent = obj.groupVar;
                    }
                    

                    // estimate column
                    const estimateCell = document.createElement("td");
                    estimateCell.style.position = "relative";
                    estimateCell.style.padding = "2px 5px";
                    estimateCell.style.minWidth = "100px";

                    const barContainer = document.createElement("div");
                    barContainer.style.position = "relative";
                    barContainer.style.height = "12px";
                    barContainer.style.background = "#eee";
                    barContainer.style.border = "1px solid #ccc";
                    barContainer.style.borderRadius = "2px";
                    barContainer.style.overflow = "hidden";

                    const bar = document.createElement("div");
                    const est = obj.estimate;
                    const percentWidth = (Math.abs(est) / maxAbs) * 50; // still relative to 50% = full side

                    bar.style.position = "absolute";
                    bar.style.top = "0";
                    bar.style.bottom = "0";
                    bar.style.background = est >= 0 ? "green" : "red";
                    bar.style.width = `${percentWidth}%`;
                    bar.style.left = est >= 0 ? "50%" : `${50 - percentWidth}%`;

                    barContainer.appendChild(bar);
                    estimateCell.appendChild(barContainer);

                    estimateCell.title = `Δ Price (${cat1} - ${cat2}) = ${est.toFixed(2)}`;      // Tooltip

                    // effect size column
                    const effectSizeCell = document.createElement("td");
                    effectSizeCell.style.position = "relative";
                    effectSizeCell.style.width = "120px";
                    effectSizeCell.style.height = "20px";
                    effectSizeCell.style.padding = "0";

                    // Create SVG container
                    const svg = d3.create("svg")
                        .attr("width", 120)
                        .attr("height", 20);

                    // CI line
                    svg.append("line")
                        .attr("x1", effectSizeScale(obj["lower.CL"]))
                        .attr("x2", effectSizeScale(obj["upper.CL"]))
                        .attr("y1", 10)
                        .attr("y2", 10)
                        .attr("stroke", "black")
                        .attr("stroke-width", 1);

                    // Effect size point
                    svg.append("circle")
                        .attr("cx", effectSizeScale(obj["effect.size"]))
                        .attr("cy", 10)
                        .attr("r", 2)
                        .attr("fill", "black");

                    // Vertical zero line (across all rows)
                    svg.append("line")
                        .attr("x1", effectSizeScale(0))
                        .attr("x2", effectSizeScale(0))
                        .attr("y1", 0)
                        .attr("y2", 20)
                        .attr("stroke", "red")
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", "2,2");

                    // Append SVG to the cell
                    effectSizeCell.appendChild(svg.node());

                    // append to table
                    [idCell, queryCell, hypoCell, groupCell, estimateCell, effectSizeCell].forEach(cell => row.appendChild(cell));
                    tbody.appendChild(row);

                    row.dataset.locked = "false";  // Track if this row has a locked plot

                    row.addEventListener("mouseenter", () => {
                        if (row.dataset.locked === "true") return;
                        row.style.backgroundColor = "#f0f0f0";

                        const visAreaId = "visarea-panel-" + model_number;
                        const visArea = document.getElementById(visAreaId);

                        let levelValue;
                        if (testType === 'level_val_interact') {
                            levelValue = row.querySelector("td:nth-child(4)")?.textContent;
                        } else if (testType === 'level_val') {
                            levelValue = "All"
                        }

                        //if (!levelValue) return;

                        const [cat1, cat2] = obj.contrast.split(" - ").map(s => s.trim());
                        const testVar = obj.testVar;
                        const groupVar = obj.groupVar;

                        const container = d3.select(visArea).append("div")
                            .attr("class", "plot-container")
                            .style("position", "relative")
                            .style("width", "200px")
                            .style("height", "200px")
                            .style("margin", "20px")
                            .attr("data-feature-x", testVar)
                            .attr("subset", levelValue)
                            .attr("category1", cat1)
                            .attr("category2", cat2)
                            .node();

                        row._attachedPlot = container; // Store reference for later removal

                        let filteredData = dataset.filter(d => [cat1, cat2].includes(d[testVar]));
                        
                        if (testType === 'level_val_interact') {
                            filteredData = filteredData.filter(d => d[groupVar] === levelValue);
                        } else if (testType === 'level_val') {
                            filteredData = dataset;
                        }

                        const var1_Obj = features.find(f => f.key === testVar);
                        const outcomeObj = features[0];

                        renderAverageBarChart(
                            container,
                            testVar,
                            outcomeObj.key,
                            var1_Obj?.name || testVar,
                            outcomeObj?.name || outcomeObj.key,
                            filteredData
                        );

                        d3.select(container)
                            .append("div")
                            .style("position", "absolute")
                            .style("top", "3px")
                            .style("right", "5px")
                            .style("background", "#eee")
                            .style("padding", "2px 6px")
                            .style("font-size", "10px")
                            .style("border-radius", "3px")
                            .text(levelValue);

                        if (droppedFeature) {
                            const levelValue = row.querySelector("td:nth-child(4)")?.textContent;
                            if (!levelValue) return;

                            const [cat1, cat2] = obj.contrast.split(" - ").map(s => s.trim());

                            const subset = dataset.filter(d => 
                                [cat1, cat2].includes(d[testVar]) && d[groupVar] === levelValue
                            );

                            const extraContainer = d3.select(visArea).append("div")
                                .attr("class", "plot-container hover-feature-plot")
                                .style("position", "relative")
                                .style("width", "200px")
                                .style("height", "200px")
                                .style("margin", "20px")
                                .node();

                            if (droppedFeature.type === "continuous") {
                                const colorDomain = [cat1, cat2];
                                const colorScale = d3.scaleOrdinal()
                                    .domain(colorDomain)
                                    .range(["#1f77b4", "#ff7f0e"]);

                                renderScatterPlot(extraContainer, droppedFeature.key, features[0].key, droppedFeature.name, features[0].name, subset, testVar, colorScale);
                            } else {
                                renderAverageBarChart(extraContainer, droppedFeature.key, features[0].key, droppedFeature.name, features[0].name, subset);
                            }
                        }

                    });

                    row.addEventListener("mouseleave", () => {

                        if (row.dataset.locked !== "true") {
                            d3.selectAll(".hover-feature-plot").remove();
                        }


                        if (row.dataset.locked === "true") return;
                        row.style.backgroundColor = "";

                        const visAreaId = "visarea-panel-" + model_number;
                        const visArea = document.getElementById(visAreaId);

                        if (row._attachedPlot && visArea.contains(row._attachedPlot)) {
                            visArea.removeChild(row._attachedPlot);
                            row._attachedPlot = null;
                        }
                    });

                    row.addEventListener("click", () => {
                        const plotContainer = row._attachedPlot;

                        const visAreaId = "visarea-panel-" + model_number;
                        const visArea = document.getElementById(visAreaId);

                        if (row.dataset.locked === "true") {
                            // Unset lock and remove plot
                            row.dataset.locked = "false";
                            row.style.backgroundColor = "";

                            if (row._attachedPlot && visArea.contains(row._attachedPlot)) {
                                visArea.removeChild(row._attachedPlot);
                                row._attachedPlot = null;
                            }
                        } else {
                            row.dataset.locked = "true";
                            row.style.backgroundColor = "#d0ffd0"; // Optional: show a different color for "locked"
                        
                            // Determine border color from p.value
                            const pvalText = row.querySelector("td:nth-child(3) span")?.title || "";
                            const isSignificant = pvalText.includes("< 0.0001") || parseFloat(pvalText.replace("p-value: ", "")) <= 0.05;
                            
                            if (plotContainer) {
                                plotContainer.style.border = `2px solid ${isSignificant ? "lightgreen" : "red"}`;
                                plotContainer.style.borderRadius = "6px";

                                // Add ID label
                                const existingLabel = plotContainer.querySelector(".id-label");
                                if (!existingLabel) {
                                    const idLabel = document.createElement("div");
                                    idLabel.className = "id-label";
                                    idLabel.textContent = `ID ${row.querySelector("td:nth-child(1)").textContent}`;
                                    Object.assign(idLabel.style, {
                                        position: "absolute",
                                        top: "-10px",
                                        left: "55px",
                                        fontSize: "10px",
                                        backgroundColor: "white",
                                        padding: "1px 4px",
                                        borderRadius: "3px",
                                        border: "1px solid #ccc",
                                        color: "#333",
                                        pointerEvents: "none"
                                    });
                                    plotContainer.appendChild(idLabel);
                                }
                            }
                        }
                    });


                });

            }
                
            
        }

        async function fitModel(formula) {
            const response = await fetch("http://localhost:8000/fit_model", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                    formula_mean: formula,
                    formula_std_dev: "~1",
                    distribution: "NO()",
                    datasetName: "airline",
                    filters: ""
                }) 
            });

            
            const data = await response.json();
            console.log(data)
            const aic = data.aic;
            const rsq = data.rsq;

            addResultPanel(formula, aic, rsq, dataset, data.result);

            awaitingStatTestResponse = true;
        }

        async function getEffectsize(formulaMean, var1, var2, contrast) {
            const response = await fetch("http://localhost:8000/get_effectSize", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                    model: formulaMean,
                    var1: var1,
                    var2: var2,
                    contrast: contrast,
                    datasetName: "airline",
                }) 
            });
            
            const result = await response.json();

            return result.results;
        }



        function removeVarFromFormula(formula, varToRemove) {
            const [lhs, rhs] = formula.split("~").map(part => part.trim());

            // Split RHS into variables, filter out var1, then join back
            const newRHS = rhs
                .split("+")
                .map(v => v.trim())
                .filter(v => v !== varToRemove)
                .join(" + ");

            return `${lhs} ~ ${newRHS}`;
        }


        async function testHypothesis(formulaMean, var1, var2, testType) {
            try {
                const response = await fetch("http://localhost:8000/test_hypothesis", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: formulaMean,
                        var1: var1,
                        var2: var2,
                        testType: testType,
                        datasetName: "airline",
                        filters: ""
                    })
                });

                const result = await response.json();

                return result.results;

            } catch (error) {
                console.log("Hypothesis test error:", error.message);
            }
        }

        function initiateDrag(event) {
            const draggedContainer = d3.select(this.parentNode);
            const visArea = draggedContainer.node().parentNode;
        
            event.stopPropagation();
            event.preventDefault();
        
            const containerRect = draggedContainer.node().getBoundingClientRect();
            const mouseOffsetX = event.clientX - containerRect.left - 10;
            const mouseOffsetY = event.clientY - containerRect.top - 10;
            const leftOffsetAdjustment = 20;
            const initialX = containerRect.left - mouseOffsetX - window.scrollX; // Relative to viewport
            const initialY = containerRect.top - mouseOffsetY - window.scrollY;
        
            console.log("Container Rect:", containerRect);
            console.log("Mouse Start:", event.clientX, event.clientY);
            console.log("Initial X, Y:", initialX, initialY);
            console.log("Mouse Offset X, Y:", mouseOffsetX, mouseOffsetY);
        
            draggedContainer
                .style("opacity", "0.5")
                .style("position", "absolute")
                .style("left", `${initialX}px`)
                .style("top", `${initialY}px`)
                .style("z-index", "100");
        
            const mouseStartX = event.clientX;
            const mouseStartY = event.clientY;
        
            let draggedIndex = Array.from(visArea.children).indexOf(draggedContainer.node());
        
            const onMouseMove = (event) => {
                const dx = event.clientX - mouseStartX;
                const dy = event.clientY - mouseStartY;
                draggedContainer
                    .style("left", `${initialX + dx}px`)
                    .style("top", `${initialY + dy}px`);
        
                const targetContainer = document.elementFromPoint(event.clientX, event.clientY)?.closest(".plot-container");
                if (targetContainer && targetContainer !== draggedContainer.node() && visArea.contains(targetContainer)) {
                    const targetIndex = Array.from(visArea.children).indexOf(targetContainer);
                    if (targetIndex !== draggedIndex && targetIndex >= 0) {
                        if (draggedIndex < targetIndex) {
                            visArea.insertBefore(draggedContainer.node(), targetContainer.nextSibling);
                        } else {
                            visArea.insertBefore(draggedContainer.node(), targetContainer);
                        }
                        draggedIndex = targetIndex;
                    }
                }
            };
        
            const onMouseUp = () => {
                draggedContainer
                    .style("opacity", "1")
                    .style("position", "relative")
                    .style("left", null)
                    .style("top", null)
                    .style("z-index", null);
        
                d3.select(document).on("mousemove", null);
                d3.select(document).on("mouseup", null);
            };
        
            d3.select(document).on("mousemove", onMouseMove);
            d3.select(document).on("mouseup", onMouseUp);
        }

        function renderEffectSizeDistribution(container, dataArray) {
            const width = 200, height = 100;
            const margin = { top: 10, right: 10, bottom: 30, left: 10 };

            // Force domain to include 0
            const extent = d3.extent(dataArray);
            const xMin = Math.min(extent[0], 0);
            const xMax = Math.max(extent[1], 0);

            const x = d3.scaleLinear()
                .domain([xMin, xMax])
                .nice()
                .range([margin.left, width - margin.right]);

            const bins = d3.bin().domain(x.domain()).thresholds(15)(dataArray);

            const y = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([height - margin.bottom, margin.top]);

            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Histogram bars
            svg.append("g")
                .selectAll("rect")
                .data(bins)
                .join("rect")
                .attr("x", d => x(d.x0) + 1)
                .attr("y", d => y(d.length))
                .attr("width", d => x(d.x1) - x(d.x0) - 1)
                .attr("height", d => y(0) - y(d.length))
                .attr("fill", "#69b3a2");

            // X-axis
            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(5).tickSize(3));

            // X-axis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height - 5)
                .attr("font-size", "10px")
                .text("Effect size");

            // Vertical red line at x = 0
            svg.append("line")
                .attr("x1", x(0))
                .attr("x2", x(0))
                .attr("y1", margin.top)
                .attr("y2", height - margin.bottom)
                .attr("stroke", "red")
                .attr("stroke-width", 1.5)
                .attr("stroke-dasharray", "4 2");

            // Vertical black line at mean
            const mean = d3.mean(dataArray);
            svg.append("line")
                .attr("x1", x(mean))
                .attr("x2", x(mean))
                .attr("y1", margin.top)
                .attr("y2", height - margin.bottom)
                .attr("stroke", "black")
                .attr("stroke-width", 1.5);
        }

        function renderEffectSizeVertical(container, dataArray, cat1, cat2, outcome, level) {

        }


    </script>

</body>
</html>
